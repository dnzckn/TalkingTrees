<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TalkingTrees - Behavior Tree Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
            height: 100vh;
        }

        /* App Layout */
        .app {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: auto 1fr 40px 30px;
            height: 100vh;
        }

        /* Toolbar */
        .toolbar {
            grid-column: 1 / -1;
            background: linear-gradient(180deg, #2d2d30 0%, #252526 100%);
            border-bottom: 1px solid #3e3e42;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            padding: 5px 15px;
            gap: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .toolbar-group {
            display: flex;
            gap: 3px;
            padding: 0 10px;
            border-right: 1px solid #3e3e42;
        }

        .toolbar-group:last-child {
            border-right: none;
            margin-left: auto;
        }

        .toolbar-group.new-row {
            flex-basis: 100%;
            border-right: none;
            margin-left: 0;
            padding-top: 5px;
            border-top: 1px solid #3e3e42;
        }

        .toolbar-btn {
            background: transparent;
            border: 1px solid transparent;
            color: #d4d4d4;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-btn:hover {
            background: #3e3e42;
            border-color: #4e4e52;
        }

        .toolbar-btn:active {
            background: #4e4e52;
        }

        .toolbar-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .toolbar-btn.primary {
            background: #0e639c;
            color: white;
        }

        .toolbar-btn.primary:hover {
            background: #1177bb;
        }

        .toolbar-btn.success {
            background: #16825d;
            color: white;
        }

        .toolbar-btn.success:hover {
            background: #1a9870;
        }

        .toolbar-icon {
            font-size: 16px;
        }

        /* Left Sidebar - Tree Library & Palette */
        .sidebar-left {
            background: #252526;
            border-right: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-tabs {
            display: flex;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
        }

        .sidebar-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: #858585;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .sidebar-tab:hover {
            background: #3e3e42;
            color: #d4d4d4;
        }

        .sidebar-tab.active {
            color: #4fc1ff;
            border-bottom-color: #4fc1ff;
            background: #252526;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 700;
            color: #858585;
            text-transform: uppercase;
            margin: 20px 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #3e3e42;
            letter-spacing: 0.5px;
        }

        .section-title:first-child {
            margin-top: 0;
        }

        /* Node Palette */
        .node-item {
            background: #37373d;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 5px;
            cursor: grab;
            border-left: 4px solid;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .node-item:hover {
            background: #3e3e42;
            transform: translateX(5px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .node-item:active {
            cursor: grabbing;
        }

        .node-item.composite {
            border-left-color: #4ec9b0;
        }

        .node-item.decorator {
            border-left-color: #dcdcaa;
        }

        .node-item.action {
            border-left-color: #4fc1ff;
        }

        .node-item.condition {
            border-left-color: #c586c0;
        }

        .node-item-title {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .node-item-desc {
            font-size: 11px;
            color: #858585;
        }

        /* Tree Library */
        .library-item {
            background: #37373d;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 4px solid #4fc1ff;
        }

        .library-item:hover {
            background: #3e3e42;
            transform: translateX(5px);
        }

        .library-item-title {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .library-item-desc {
            font-size: 11px;
            color: #858585;
            margin-bottom: 8px;
        }

        .library-item-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            font-size: 10px;
            color: #858585;
        }

        .library-search {
            width: 100%;
            padding: 10px;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            border-radius: 5px;
            color: #d4d4d4;
            font-size: 13px;
            margin-bottom: 15px;
        }

        .library-search:focus {
            outline: none;
            border-color: #0e639c;
        }

        /* Canvas Area */
        .canvas-area {
            background: #1e1e1e;
            position: relative;
            overflow: hidden;
        }

        #treeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        .canvas-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(37, 37, 38, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            border: 1px solid #3e3e42;
            max-width: 350px;
        }

        .canvas-overlay.connect-mode {
            background: rgba(243, 156, 18, 0.95);
            color: white;
            font-weight: 600;
        }

        /* Minimap hover effect */
        #minimapCanvas:hover {
            opacity: 0.9;
        }

        #minimapPanel {
            transition: border-color 0.2s ease;
        }

        #minimapPanel:hover {
            border-color: #4fc1ff !important;
        }

        /* Right Sidebar - Properties */
        .sidebar-right {
            background: #252526;
            border-left: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .properties-header {
            background: #2d2d30;
            padding: 12px 15px;
            border-bottom: 1px solid #3e3e42;
            font-weight: 600;
            font-size: 13px;
        }

        .properties-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .prop-group {
            margin-bottom: 18px;
        }

        .prop-label {
            font-size: 11px;
            font-weight: 600;
            color: #858585;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .prop-input,
        .prop-select {
            width: 100%;
            padding: 10px;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            border-radius: 5px;
            color: #d4d4d4;
            font-size: 13px;
            font-family: inherit;
            transition: all 0.2s;
        }

        .prop-input:focus,
        .prop-select:focus {
            outline: none;
            border-color: #0e639c;
            background: #404040;
        }

        .prop-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #3c3c3c;
            border-radius: 5px;
            cursor: pointer;
        }

        .prop-checkbox input {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .prop-checkbox label {
            flex: 1;
            cursor: pointer;
            font-size: 13px;
        }

        .prop-btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s;
        }

        .prop-btn.danger {
            background: #e74c3c;
            color: white;
        }

        .prop-btn.danger:hover {
            background: #c0392b;
        }

        .prop-btn.secondary {
            background: #3e3e42;
            color: white;
        }

        .prop-btn.secondary:hover {
            background: #4e4e52;
        }

        .validation-message {
            background: #3e2723;
            border-left: 4px solid #e74c3c;
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
        }

        .validation-message.warning {
            background: #3e3520;
            border-left-color: #f39c12;
        }

        .validation-message.success {
            background: #1e3e2e;
            border-left-color: #27ae60;
        }

        /* Timeline Scrubber */
        .timeline-scrubber {
            grid-column: 1 / -1;
            background: #1e1e1e;
            border-top: 1px solid #3e3e42;
            padding: 5px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            color: #d4d4d4;
            height: 40px;
        }

        .timeline-btn {
            background: #3e3e42;
            border: none;
            color: #d4d4d4;
            padding: 4px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.15s;
        }

        .timeline-btn:hover {
            background: #4e4e52;
        }

        .timeline-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .timeline-track {
            flex: 1;
            height: 20px;
            background: #2d2d30;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            border: 1px solid #3e3e42;
        }

        .timeline-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .timeline-handle {
            position: absolute;
            top: -2px;
            width: 12px;
            height: 24px;
            background: #4fc1ff;
            border-radius: 4px;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: background 0.15s;
        }

        .timeline-handle:hover {
            background: #6dcff6;
        }

        .timeline-handle:active {
            cursor: grabbing;
            background: #2ea5d9;
        }

        .timeline-info {
            min-width: 140px;
            font-size: 11px;
            color: #858585;
            font-family: 'Consolas', monospace;
        }

        .timeline-info strong {
            color: #4fc1ff;
        }

        /* Status Bar */
        .statusbar {
            grid-column: 1 / -1;
            background: #0e639c;
            color: white;
            padding: 0 15px;
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 11px;
            font-weight: 500;
        }

        .statusbar-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .statusbar-separator {
            width: 1px;
            height: 16px;
            background: rgba(255, 255, 255, 0.3);
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 25px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #4fc1ff;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-input {
            width: 100%;
            padding: 12px;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            border-radius: 5px;
            color: #d4d4d4;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .modal-input:focus {
            outline: none;
            border-color: #0e639c;
        }

        .modal-textarea {
            width: 100%;
            padding: 12px;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            border-radius: 5px;
            color: #d4d4d4;
            font-size: 13px;
            font-family: inherit;
            min-height: 100px;
            resize: vertical;
        }

        .modal-textarea:focus {
            outline: none;
            border-color: #0e639c;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
        }

        .modal-btn.primary {
            background: #0e639c;
            color: white;
        }

        .modal-btn.primary:hover {
            background: #1177bb;
        }

        .modal-btn.secondary {
            background: #3e3e42;
            color: white;
        }

        .modal-btn.secondary:hover {
            background: #4e4e52;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            padding: 5px 0;
            min-width: 180px;
            z-index: 10000;
            display: none;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
            color: #d4d4d4;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.15s;
        }

        .context-menu-item:hover {
            background: #37373d;
        }

        .context-menu-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background: transparent;
        }

        .context-menu-separator {
            height: 1px;
            background: #3e3e42;
            margin: 5px 0;
        }

        .context-menu-shortcut {
            margin-left: auto;
            font-size: 11px;
            color: #808080;
        }

        .context-menu-header {
            padding: 8px 20px 4px 20px;
            color: #4fc1ff;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .context-menu-item.has-submenu {
            position: relative;
        }

        .context-submenu {
            position: absolute;
            left: 100%;
            top: -5px;
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            padding: 5px 0;
            min-width: 180px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 10001;
        }

        .context-menu-item.has-submenu:hover .context-submenu {
            display: block !important;
        }

        /* Keyboard Shortcuts Panel */
        .shortcut-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 8px 0;
            font-size: 13px;
            color: #d4d4d4;
        }

        .shortcut-item kbd {
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            font-family: 'Segoe UI', monospace;
            color: #fff;
            box-shadow: 0 2px 0 #1e1e1e;
            min-width: 60px;
            text-align: center;
            font-weight: 600;
        }

        .shortcut-item span {
            flex: 1;
        }

        /* Validation Messages */
        .validation-message {
            background: #37373d;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            border-left: 4px solid #4fc1ff;
            line-height: 1.6;
        }

        .validation-message.success {
            background: rgba(76, 175, 80, 0.15);
            border-left-color: #4caf50;
            color: #81c784;
        }

        .validation-message.error {
            background: rgba(229, 57, 53, 0.15);
            border-left-color: #e53935;
            color: #e57373;
        }

        .validation-message.warning {
            background: rgba(255, 152, 0, 0.15);
            border-left-color: #ff9800;
            color: #ffb74d;
        }

        .validation-message.info {
            background: rgba(33, 150, 243, 0.15);
            border-left-color: #2196f3;
            color: #64b5f6;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3e3e42;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4e4e52;
        }

        /* Tooltips */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #2d2d30;
            color: #d4d4d4;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            margin-bottom: 5px;
            border: 1px solid #3e3e42;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 10000;
        }

        /* Left-aligned tooltip for items on the left edge */
        .tooltip-left[data-tooltip]:hover::after {
            left: 0;
            transform: translateX(0);
        }

        /* Grid toggle */
        .canvas-grid {
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        /* Toast Notification Animations */
        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <!-- Hidden file input for importing JSON files -->
    <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">

    <div class="app">
        <!-- Toolbar -->
        <div class="toolbar">
            <!-- File Operations -->
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="newTree()" data-tooltip="New Tree (Ctrl+N)">
                    <span class="toolbar-icon">üìÑ</span> New
                </button>
                <button class="toolbar-btn" onclick="openLoadModal()" data-tooltip="Load Tree from Library">
                    <span class="toolbar-icon">üìö</span> Load
                </button>
                <button class="toolbar-btn" onclick="document.getElementById('fileInput').click()" data-tooltip="Import from File">
                    <span class="toolbar-icon">üìÅ</span> Import
                </button>
                <button class="toolbar-btn" onclick="saveToLibrary()" data-tooltip="Save to Library (Ctrl+S)">
                    <span class="toolbar-icon">üíæ</span> Save
                </button>
            </div>

            <!-- Edit Operations -->
            <div class="toolbar-group">
                <button class="toolbar-btn" id="undoBtn" onclick="undo()" disabled data-tooltip="Undo (Ctrl+Z)">
                    <span class="toolbar-icon">‚Ü∂</span> Undo
                </button>
                <button class="toolbar-btn" id="redoBtn" onclick="redo()" disabled data-tooltip="Redo (Ctrl+Y)">
                    <span class="toolbar-icon">‚Ü∑</span> Redo
                </button>
                <button class="toolbar-btn" id="connectBtn" onclick="toggleConnectMode()"
                    data-tooltip="Connect Mode: Click parent, then child">
                    <span class="toolbar-icon">üîó</span> Connect
                </button>
                <button class="toolbar-btn" id="loadExampleBtn" onclick="loadRobotExample()"
                    data-tooltip="Load Robot Controller Example">
                    <span class="toolbar-icon">ü§ñ</span> Example
                </button>
            </div>

            <!-- View Operations -->
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="autoLayout()" data-tooltip="Auto Layout (Ctrl+L)">
                    <span class="toolbar-icon">üéØ</span> Layout
                </button>
                <button class="toolbar-btn" onclick="zoomIn()" data-tooltip="Zoom In (+)">
                    <span class="toolbar-icon">üîç+</span>
                </button>
                <button class="toolbar-btn" onclick="zoomOut()" data-tooltip="Zoom Out (-)">
                    <span class="toolbar-icon">üîç-</span>
                </button>
                <button class="toolbar-btn" onclick="zoomFit()" data-tooltip="Fit to View (Ctrl+0)">
                    <span class="toolbar-icon">‚ä°</span> Fit
                </button>
                <button class="toolbar-btn" id="gridBtn" onclick="toggleGrid()" data-tooltip="Toggle Grid (Ctrl+G)">
                    <span class="toolbar-icon">#</span> Grid
                </button>
                <button class="toolbar-btn" onclick="toggleMinimap()" data-tooltip="Toggle Minimap">
                    <span class="toolbar-icon">üó∫Ô∏è</span> Map
                </button>
            </div>

            <!-- Export Operations -->
            <div class="toolbar-group">
                <button class="toolbar-btn success" onclick="exportTree()" data-tooltip="Download tree as JSON file">
                    <span class="toolbar-icon">‚¨áÔ∏è</span> Download
                </button>
                <button class="toolbar-btn primary" onclick="saveToAPI()" data-tooltip="Publish tree to API server">
                    <span class="toolbar-icon">‚òÅÔ∏è</span> Publish
                </button>
                <button class="toolbar-btn" onclick="openCopyPythonModal()"
                    data-tooltip="Get Python SDK code to load and run this tree" style="background: #c586c0;">
                    <span class="toolbar-icon">üêç</span> Get Code
                </button>
            </div>

            <!-- Validation & Help -->
            <div class="toolbar-group">
                <button class="toolbar-btn" id="validateBtn" onclick="validateTree()"
                    data-tooltip="Validate Tree (Ctrl+Shift+V)">
                    <span class="toolbar-icon">‚úì</span> Validate
                </button>
            </div>

            <!-- Simulation Controls -->
            <div class="toolbar-group new-row" style="background: rgba(76, 175, 80, 0.1); padding: 4px 8px; border-radius: 4px;">
                <span class="tooltip-left" style="color: #4fc1ff; font-size: 11px; margin-right: 8px; cursor: help;"
                    data-tooltip="‚ö†Ô∏è Mock simulator - visualizes flow only, no real code execution">
                    ‚ÑπÔ∏è Sim
                </span>
                <span id="simTickCounter" style="font-size: 12px; color: #27ae60; font-weight: 600; margin-right: 10px; min-width: 60px; display: inline-block;"
                    data-tooltip="Current simulation tick">
                    Tick: 0
                </span>
                <label style="display: inline-flex; align-items: center; margin-right: 10px; cursor: pointer; user-select: none;"
                    data-tooltip="Toggle between Manual (step-only) and Auto (play with speed control) modes">
                    <input type="checkbox" id="simModeToggle" onchange="toggleSimulationMode()"
                        style="margin-right: 4px; cursor: pointer;">
                    <span id="simModeLabel" style="font-size: 12px; color: #d4d4d4;">Auto</span>
                </label>
                <button class="toolbar-btn" id="simPlayBtn" onclick="toggleSimulation()"
                    data-tooltip="Run Simulation (Space)" style="background: #4caf50;">
                    <span class="toolbar-icon">‚ñ∂</span> Run
                </button>
                <button class="toolbar-btn" id="simStepBtn" onclick="stepSimulation()"
                    data-tooltip="Step Forward (‚Üí)" disabled>
                    <span class="toolbar-icon">‚è≠</span> Step
                </button>
                <button class="toolbar-btn" id="simResetBtn" onclick="resetSimulation()"
                    data-tooltip="Reset Simulation" disabled>
                    <span class="toolbar-icon">‚èπ</span> Reset
                </button>
                <span style="display: inline-flex; align-items: center; margin: 0 6px; gap: 4px;">
                    <label style="font-size: 11px; color: #d4d4d4;">TPS:</label>
                    <input type="number" id="simSpeedInput" min="0.1" max="100" step="0.1" value="1"
                        style="width: 50px; padding: 2px 4px; background: #3c3c3c; border: 1px solid #3e3e42; border-radius: 3px; color: #d4d4d4; font-size: 11px;"
                        data-tooltip="Ticks Per Second (0.1 - 100)"
                        oninput="updateSimSpeedFromTPS(this.value)">
                    <input type="range" id="simSpeedSlider" min="0.1" max="100" step="0.1" value="1"
                        style="width: 80px; vertical-align: middle;"
                        data-tooltip="Ticks Per Second"
                        oninput="updateSimSpeedFromSlider(this.value)">
                </span>
                <button class="toolbar-btn" id="blackboardToggle" onclick="toggleBlackboard()"
                    data-tooltip="Toggle Blackboard Inspector" style="background: #2196f3;">
                    <span class="toolbar-icon">üìä</span> BB
                </button>
            </div>

            <!-- Search -->
            <div class="toolbar-group" style="flex: 1; max-width: 250px;">
                <input type="text" id="nodeSearchInput" placeholder="üîç Search nodes..."
                    style="width: 100%; padding: 8px 12px; background: #3c3c3c; border: 1px solid #3e3e42; border-radius: 4px; color: #d4d4d4; font-size: 13px;"
                    oninput="searchNodes(this.value)"
                    onkeydown="if(event.key==='Escape') this.value=''; searchNodes('');">
            </div>
        </div>

        <!-- Left Sidebar -->
        <div class="sidebar-left">
            <div class="sidebar-tabs">
                <div class="sidebar-tab active" onclick="switchTab('palette')">Node Palette</div>
                <div class="sidebar-tab" onclick="switchTab('library')">Library</div>
            </div>
            <div class="sidebar-content" id="paletteTab">
                <input type="text" class="library-search" id="paletteSearch" placeholder="Search nodes..."
                    onkeyup="filterPalette()">

                <!-- COMPOSITES SECTION -->
                <div class="section-title">COMPOSITES (3)</div>
                <div class="palette-nodes" id="compositesGroup">
                    <div class="node-item composite" draggable="true" data-type="Sequence"
                        data-search="sequence order sequential and">
                        <div class="node-item-title">Sequence</div>
                        <div class="node-item-desc">Execute children in order (AND logic)</div>
                    </div>
                    <div class="node-item composite" draggable="true" data-type="Selector"
                        data-search="selector priority fallback or">
                        <div class="node-item-title">Selector</div>
                        <div class="node-item-desc">Try children until success (OR logic)</div>
                    </div>
                    <div class="node-item composite" draggable="true" data-type="Parallel"
                        data-search="parallel concurrent simultaneous">
                        <div class="node-item-title">Parallel</div>
                        <div class="node-item-desc">Execute children concurrently</div>
                    </div>
                </div>

                <!-- DECORATORS SECTION -->
                <div class="section-title">DECORATORS (14)</div>

                <div style="font-size: 10px; font-weight: 600; color: #6c6c6c; margin: 8px 0 4px 8px;">Status Converters</div>
                <div class="palette-nodes" id="statusConvertersGroup">
                    <div class="node-item decorator" draggable="true" data-type="Inverter"
                        data-search="inverter not flip reverse">
                        <div class="node-item-title">Inverter</div>
                        <div class="node-item-desc">Flip SUCCESS ‚áÑ FAILURE</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="SuccessIsFailure"
                        data-search="success failure convert">
                        <div class="node-item-title">Success Is Failure</div>
                        <div class="node-item-desc">Convert SUCCESS ‚Üí FAILURE</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="FailureIsSuccess"
                        data-search="failure success convert">
                        <div class="node-item-title">Failure Is Success</div>
                        <div class="node-item-desc">Convert FAILURE ‚Üí SUCCESS</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="FailureIsRunning"
                        data-search="failure running convert">
                        <div class="node-item-title">Failure Is Running</div>
                        <div class="node-item-desc">Convert FAILURE ‚Üí RUNNING</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="RunningIsFailure"
                        data-search="running failure convert">
                        <div class="node-item-title">Running Is Failure</div>
                        <div class="node-item-desc">Convert RUNNING ‚Üí FAILURE</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="RunningIsSuccess"
                        data-search="running success convert">
                        <div class="node-item-title">Running Is Success</div>
                        <div class="node-item-desc">Convert RUNNING ‚Üí SUCCESS</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="SuccessIsRunning"
                        data-search="success running convert">
                        <div class="node-item-title">Success Is Running</div>
                        <div class="node-item-desc">Convert SUCCESS ‚Üí RUNNING</div>
                    </div>
                </div>

                <div style="font-size: 10px; font-weight: 600; color: #6c6c6c; margin: 8px 0 4px 8px;">Repetition & Control</div>
                <div class="palette-nodes" id="repetitionGroup">
                    <div class="node-item decorator" draggable="true" data-type="Retry"
                        data-search="retry repeat attempts failure">
                        <div class="node-item-title">Retry</div>
                        <div class="node-item-desc">Retry child N times on failure</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="Repeat"
                        data-search="repeat loop times success">
                        <div class="node-item-title">Repeat</div>
                        <div class="node-item-desc">Repeat child N times until success</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="OneShot"
                        data-search="oneshot once single execute">
                        <div class="node-item-title">One Shot</div>
                        <div class="node-item-desc">Execute once, then return fixed status</div>
                    </div>
                </div>

                <div style="font-size: 10px; font-weight: 600; color: #6c6c6c; margin: 8px 0 4px 8px;">Conditionals & Monitoring</div>
                <div class="palette-nodes" id="conditionalDecGroup">
                    <div class="node-item decorator" draggable="true" data-type="Timeout"
                        data-search="timeout timer duration deadline">
                        <div class="node-item-title">Timeout</div>
                        <div class="node-item-desc">Fail if child takes too long</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="EternalGuard"
                        data-search="eternal guard continuous monitor condition">
                        <div class="node-item-title">Eternal Guard</div>
                        <div class="node-item-desc">Continuous condition monitoring</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="Condition"
                        data-search="condition wait blocking guard">
                        <div class="node-item-title">Condition</div>
                        <div class="node-item-desc">Blocking conditional decorator</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="Count"
                        data-search="count statistics track monitor">
                        <div class="node-item-title">Count</div>
                        <div class="node-item-desc">Track execution statistics</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="StatusToBlackboard"
                        data-search="status blackboard write store">
                        <div class="node-item-title">Status To Blackboard</div>
                        <div class="node-item-desc">Write child status to blackboard</div>
                    </div>
                    <div class="node-item decorator" draggable="true" data-type="PassThrough"
                        data-search="passthrough debug transparent">
                        <div class="node-item-title">Pass Through</div>
                        <div class="node-item-desc">No-op decorator for debugging</div>
                    </div>
                </div>

                <!-- ACTIONS SECTION -->
                <div class="section-title">ACTIONS (13+)</div>

                <div style="font-size: 10px; font-weight: 600; color: #6c6c6c; margin: 8px 0 4px 8px;">Basic Status</div>
                <div class="palette-nodes" id="basicStatusGroup">
                    <div class="node-item action" draggable="true" data-type="Success"
                        data-search="success always true pass">
                        <div class="node-item-title">Success</div>
                        <div class="node-item-desc">Always return SUCCESS</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="Failure"
                        data-search="failure always false fail">
                        <div class="node-item-title">Failure</div>
                        <div class="node-item-desc">Always return FAILURE</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="Running"
                        data-search="running always pending">
                        <div class="node-item-title">Running</div>
                        <div class="node-item-desc">Always return RUNNING</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="Dummy"
                        data-search="dummy test placeholder">
                        <div class="node-item-title">Dummy</div>
                        <div class="node-item-desc">Crash test dummy for testing</div>
                    </div>
                </div>

                <div style="font-size: 10px; font-weight: 600; color: #6c6c6c; margin: 8px 0 4px 8px;">Time-Based</div>
                <div class="palette-nodes" id="timeBasedGroup">
                    <div class="node-item action" draggable="true" data-type="Wait"
                        data-search="wait sleep delay pause timer">
                        <div class="node-item-title">Wait</div>
                        <div class="node-item-desc">Wait for duration</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="TickCounter"
                        data-search="tick counter count number">
                        <div class="node-item-title">Tick Counter</div>
                        <div class="node-item-desc">Count N ticks before completing</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="SuccessEveryN"
                        data-search="success every n periodic interval">
                        <div class="node-item-title">Success Every N</div>
                        <div class="node-item-desc">Return SUCCESS every N ticks</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="Periodic"
                        data-search="periodic cycle rotate status">
                        <div class="node-item-title">Periodic</div>
                        <div class="node-item-desc">Cycle through statuses periodically</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="StatusQueue"
                        data-search="status queue sequence list">
                        <div class="node-item-title">Status Queue</div>
                        <div class="node-item-desc">Cycle through predefined status queue</div>
                    </div>
                </div>

                <div style="font-size: 10px; font-weight: 600; color: #6c6c6c; margin: 8px 0 4px 8px;">Blackboard Operations</div>
                <div class="palette-nodes" id="blackboardActionsGroup">
                    <div class="node-item action" draggable="true" data-type="SetBlackboardVariable"
                        data-search="set write variable store blackboard">
                        <div class="node-item-title">Set Variable</div>
                        <div class="node-item-desc">Write to blackboard (REAL ACTION)</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="GetBlackboardVariable"
                        data-search="get read variable fetch blackboard">
                        <div class="node-item-title">Get Variable</div>
                        <div class="node-item-desc">Read from blackboard</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="UnsetBlackboardVariable"
                        data-search="unset delete remove clear blackboard">
                        <div class="node-item-title">Unset Variable</div>
                        <div class="node-item-desc">Remove blackboard variable</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="BlackboardToStatus"
                        data-search="blackboard status read return">
                        <div class="node-item-title">Blackboard To Status</div>
                        <div class="node-item-desc">Return status from blackboard</div>
                    </div>
                </div>

                <div style="font-size: 10px; font-weight: 600; color: #6c6c6c; margin: 8px 0 4px 8px;">Utilities</div>
                <div class="palette-nodes" id="utilitiesGroup">
                    <div class="node-item action" draggable="true" data-type="Log"
                        data-search="log print debug message console">
                        <div class="node-item-title">Log</div>
                        <div class="node-item-desc">Log message (debug only)</div>
                    </div>
                    <div class="node-item action" draggable="true" data-type="CheckBlackboardCondition"
                        data-search="check blackboard condition test if">
                        <div class="node-item-title">Check Blackboard Condition</div>
                        <div class="node-item-desc">Check blackboard value with operator</div>
                    </div>
                </div>

                <!-- CONDITIONS SECTION -->
                <div class="section-title">CONDITIONS (5)</div>
                <div class="palette-nodes" id="conditionsGroup">
                    <div class="node-item condition" draggable="true" data-type="CheckBlackboardVariableExists"
                        data-search="check exists has key blackboard">
                        <div class="node-item-title">Check Variable Exists</div>
                        <div class="node-item-desc">Check if blackboard key exists</div>
                    </div>
                    <div class="node-item condition" draggable="true" data-type="WaitForBlackboardVariable"
                        data-search="wait blackboard variable exists blocking">
                        <div class="node-item-title">Wait For Variable</div>
                        <div class="node-item-desc">Blocking wait for variable existence</div>
                    </div>
                    <div class="node-item condition" draggable="true" data-type="WaitForBlackboardVariableValue"
                        data-search="wait blackboard value condition blocking">
                        <div class="node-item-title">Wait For Value</div>
                        <div class="node-item-desc">Blocking wait for value condition</div>
                    </div>
                    <div class="node-item condition" draggable="true" data-type="CheckBlackboardVariableValue"
                        data-search="check blackboard value condition test">
                        <div class="node-item-title">Check Variable Value</div>
                        <div class="node-item-desc">Check single blackboard condition</div>
                    </div>
                    <div class="node-item condition" draggable="true" data-type="CheckBlackboardVariableValues"
                        data-search="check blackboard multiple conditions and or">
                        <div class="node-item-title">Check Multiple Values</div>
                        <div class="node-item-desc">Check multiple conditions with AND/OR</div>
                    </div>
                </div>

                <!-- PROBABILISTIC SECTION -->
                <div class="section-title">PROBABILISTIC (1)</div>
                <div class="palette-nodes" id="probabilisticGroup">
                    <div class="node-item action" draggable="true" data-type="ProbabilisticBehaviour"
                        data-search="probabilistic random weighted chance">
                        <div class="node-item-title">Probabilistic Behaviour</div>
                        <div class="node-item-desc">Weighted random status selection</div>
                    </div>
                </div>
            </div>
            <div class="sidebar-content" id="libraryTab" style="display: none;">
                <div style="padding: 10px; background: #2d2d30; margin: -15px -15px 10px -15px; border-bottom: 1px solid #3e3e42;">
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <label style="display: inline-flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="radio" name="libMode" value="local" checked onchange="loadLibraryMode('local')" style="cursor: pointer;">
                                <span style="color: #d4d4d4; font-size: 12px;">Local</span>
                            </label>
                            <label style="display: inline-flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="radio" name="libMode" value="remote" onchange="loadLibraryMode('remote')" style="cursor: pointer;">
                                <span style="color: #d4d4d4; font-size: 12px;">Remote</span>
                            </label>
                        </div>
                        <button onclick="openFolderPicker()" style="background: #3e3e42; border: 1px solid #555; color: #d4d4d4; padding: 4px 8px; border-radius: 3px; font-size: 11px; cursor: pointer; white-space: nowrap;" title="Load trees from a folder on your computer">
                            üìÅ Open Folder
                        </button>
                    </div>
                    <input type="text" class="library-search" id="librarySearch" placeholder="Search library..."
                        onkeyup="filterLibrary()" style="margin: 0;">
                </div>
                <div id="libraryContent">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-area" id="canvasArea">
            <canvas id="treeCanvas"></canvas>
        </div>

        <!-- Right Sidebar -->
        <div class="sidebar-right">
            <div class="properties-header">Properties</div>
            <div class="properties-content" id="propertiesContent">
                <div style="color: #858585; text-align: center; padding: 40px 20px;">
                    Select a node to edit its properties
                </div>
            </div>
        </div>

        <!-- Blackboard Inspector -->
        <div id="blackboardPanel" class="draggable-panel" style="display: none; position: absolute; right: 20px; top: 60px; width: 300px; min-width: 250px; background: #252526; border: 1px solid #3e3e42; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 100; resize: both; overflow: hidden;">
            <div class="panel-header" style="padding: 12px; border-bottom: 1px solid #3e3e42; display: flex; justify-content: space-between; align-items: center; cursor: move;">
                <strong style="color: #4fc1ff;">üìä Blackboard</strong>
                <button onclick="toggleBlackboard()" style="background: none; border: none; color: #858585; cursor: pointer; font-size: 18px;">√ó</button>
            </div>
            <div id="blackboardContent" style="padding: 12px; max-height: 450px; overflow-y: auto;">
                <div style="color: #858585; font-size: 12px; text-align: center; padding: 20px;">
                    Run simulation to see blackboard variables
                </div>
            </div>
        </div>

        <!-- Minimap -->
        <div id="minimapPanel" class="draggable-panel" style="position: absolute; bottom: 80px; right: 20px; width: 200px; min-width: 150px; background: rgba(30, 30, 30, 0.9); border: 2px solid #3e3e42; border-radius: 8px; z-index: 100; resize: both; overflow: hidden;">
            <div class="panel-header" style="padding: 6px 10px; border-bottom: 1px solid #3e3e42; display: flex; justify-content: space-between; align-items: center; background: rgba(40, 40, 40, 0.95); cursor: move;">
                <strong style="color: #4fc1ff; font-size: 11px;">üó∫Ô∏è Minimap</strong>
                <button onclick="toggleMinimap()" style="background: none; border: none; color: #858585; cursor: pointer; font-size: 14px;">√ó</button>
            </div>
            <canvas id="minimapCanvas" width="200" height="150" style="display: block; cursor: pointer;"></canvas>
        </div>

        <!-- Timeline Scrubber -->
        <div class="timeline-scrubber" id="timelineScrubber" style="display: none;">
            <button class="timeline-btn" onclick="prevTick()" id="prevTickBtn" disabled title="Previous Tick (‚Üê)">‚óÄ</button>
            <div class="timeline-track" id="timelineTrack" onmousedown="startTimelineDrag(event)" onclick="jumpToTimelinePosition(event)">
                <canvas class="timeline-canvas" id="timelineCanvas" width="800" height="20"></canvas>
                <div class="timeline-handle" id="timelineHandle"></div>
            </div>
            <button class="timeline-btn" onclick="nextTick()" id="nextTickBtn" disabled title="Next Tick (‚Üí)">‚ñ∂</button>
            <div class="timeline-info">
                <span id="timelineTickInfo">No history</span>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="statusbar">
            <div class="statusbar-item">
                <span id="statusMessage">Ready</span>
            </div>
            <div class="statusbar-separator"></div>
            <div class="statusbar-item">
                Nodes: <strong id="nodeCount">0</strong>
            </div>
            <div class="statusbar-separator"></div>
            <div class="statusbar-item">
                Connections: <strong id="connectionCount">0</strong>
            </div>
            <div class="statusbar-separator"></div>
            <div class="statusbar-item">
                Selected: <strong id="selectedCount">0</strong>
            </div>
            <div class="statusbar-separator"></div>
            <div class="statusbar-item">
                Zoom: <strong id="zoomLevel">100%</strong>
            </div>
            <div class="statusbar-separator"></div>
            <div class="statusbar-item" id="treeNameDisplay">
                <strong>Untitled Tree</strong>
            </div>
            <div class="statusbar-separator"></div>
            <div class="statusbar-item" id="breadcrumbPath"
                style="flex: 1; min-width: 200px; font-size: 11px; color: #858585;">
                <span id="pathText"></span>
            </div>
        </div>
    </div>

    <!-- Toast Notifications Container -->
    <div id="toastContainer" style="position: fixed; bottom: 100px; right: 20px; z-index: 10000; display: flex; flex-direction: column-reverse; gap: 10px; pointer-events: none;"></div>

    <!-- Node Tooltip -->
    <div id="nodeTooltip" style="display: none; position: fixed; background: rgba(30, 30, 30, 0.98); border: 1px solid #4fc1ff; border-radius: 6px; padding: 12px 16px; z-index: 10001; max-width: 400px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); pointer-events: none;">
        <div style="color: #4fc1ff; font-weight: 600; font-size: 13px; margin-bottom: 6px;" id="tooltipTitle"></div>
        <div style="color: #cccccc; font-size: 12px; line-height: 1.5;" id="tooltipDescription"></div>
        <div style="color: #858585; font-size: 11px; margin-top: 8px; padding-top: 8px; border-top: 1px solid #3e3e42;" id="tooltipConfig"></div>
    </div>

    <!-- Save Modal -->
    <div class="modal-overlay" id="saveModal">
        <div class="modal">
            <div class="modal-title">Save Tree to Library</div>
            <div class="modal-body">
                <input type="text" class="modal-input" id="saveTreeName"
                    placeholder="Tree Name (e.g., Robot Controller)">
                <textarea class="modal-textarea" id="saveTreeDesc" placeholder="Description..."></textarea>
            </div>
            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="closeModal('saveModal')">Cancel</button>
                <button class="modal-btn primary" onclick="confirmSaveToLibrary()">Save</button>
            </div>
        </div>
    </div>

    <!-- Load Modal -->
    <div class="modal-overlay" id="loadModal">
        <div class="modal">
            <div class="modal-title">Load Tree</div>
            <div style="padding: 12px 20px; border-bottom: 1px solid #3e3e42; display: flex; align-items: center; gap: 15px;">
                <span style="color: #d4d4d4; font-size: 13px;">Mode:</span>
                <label style="display: inline-flex; align-items: center; gap: 6px; cursor: pointer;">
                    <input type="radio" name="loadMode" value="local" checked onchange="switchLoadMode('local')" style="cursor: pointer;">
                    <span style="color: #d4d4d4; font-size: 13px;">Local Examples</span>
                </label>
                <label style="display: inline-flex; align-items: center; gap: 6px; cursor: pointer;">
                    <input type="radio" name="loadMode" value="remote" onchange="switchLoadMode('remote')" style="cursor: pointer;">
                    <span style="color: #d4d4d4; font-size: 13px;">Remote API</span>
                </label>
            </div>
            <div class="modal-body" id="loadModalContent">
                <!-- Populated dynamically -->
            </div>
            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="closeModal('loadModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div class="modal-overlay" id="shortcutsModal">
        <div class="modal" style="max-width: 900px;">
            <div class="modal-title">‚å®Ô∏è Keyboard Shortcuts</div>
            <div class="modal-body" style="max-height: 600px; overflow-y: auto;">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                    <div>
                        <h3 style="color: #4fc1ff; margin-bottom: 10px; font-size: 14px;">File Operations</h3>
                        <div class="shortcut-item"><kbd>Ctrl+N</kbd><span>New Tree</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+S</kbd><span>Save to Library</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+Shift+P</kbd><span>Command Palette</span></div>

                        <h3 style="color: #4fc1ff; margin: 15px 0 10px; font-size: 14px;">Edit Operations</h3>
                        <div class="shortcut-item"><kbd>Ctrl+Z</kbd><span>Undo</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+Y</kbd><span>Redo</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+C</kbd><span>Copy Node</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+Shift+C</kbd><span>Copy Node Path</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+X</kbd><span>Cut</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+V</kbd><span>Paste</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+Shift+V</kbd><span>Validate Tree</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+D</kbd><span>Duplicate</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+A</kbd><span>Select All</span></div>
                        <div class="shortcut-item"><kbd>Delete</kbd><span>Delete Node</span></div>
                        <div class="shortcut-item"><kbd>DD</kbd><span>Delete (vim-style)</span></div>
                        <div class="shortcut-item"><kbd>Backspace</kbd><span>Disconnect from Parent</span></div>
                    </div>
                    <div>
                        <h3 style="color: #4fc1ff; margin-bottom: 10px; font-size: 14px;">View Operations</h3>
                        <div class="shortcut-item"><kbd>Ctrl+L</kbd><span>Auto Layout</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+G</kbd><span>Toggle Grid</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+0</kbd><span>Zoom to Fit</span></div>
                        <div class="shortcut-item"><kbd>+</kbd><span>Zoom In</span></div>
                        <div class="shortcut-item"><kbd>-</kbd><span>Zoom Out</span></div>
                        <div class="shortcut-item"><kbd>Space+Drag</kbd><span>Pan Canvas</span></div>

                        <h3 style="color: #4fc1ff; margin: 15px 0 10px; font-size: 14px;">Navigation</h3>
                        <div class="shortcut-item"><kbd>‚Üë</kbd><span>Select Parent</span></div>
                        <div class="shortcut-item"><kbd>‚Üì</kbd><span>Select First Child</span></div>
                        <div class="shortcut-item"><kbd>‚Üê</kbd><span>Select Previous Sibling</span></div>
                        <div class="shortcut-item"><kbd>‚Üí</kbd><span>Select Next Sibling</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+F</kbd><span>Search Nodes</span></div>
                    </div>
                    <div>
                        <h3 style="color: #4fc1ff; margin-bottom: 10px; font-size: 14px;">Node Operations</h3>
                        <div class="shortcut-item"><kbd>F2</kbd><span>Rename Node</span></div>
                        <div class="shortcut-item"><kbd>Enter</kbd><span>Toggle Collapse</span></div>
                        <div class="shortcut-item"><kbd>S</kbd><span>Toggle Connect Mode</span></div>
                        <div class="shortcut-item"><kbd>Escape</kbd><span>Clear Selection / Exit Mode</span></div>
                        <div class="shortcut-item"><kbd>Shift+Click</kbd><span>Multi-select</span></div>
                        <div class="shortcut-item"><kbd>Right-Click</kbd><span>Context Menu</span></div>

                        <h3 style="color: #4fc1ff; margin: 15px 0 10px; font-size: 14px;">Help</h3>
                        <div class="shortcut-item"><kbd>F1</kbd><span>Show Shortcuts</span></div>
                        <div class="shortcut-item"><kbd>?</kbd><span>Show Shortcuts</span></div>
                    </div>
                </div>
                <div style="margin-top: 20px; padding: 15px; background: rgba(79, 193, 255, 0.1); border-radius: 8px; border-left: 3px solid #4fc1ff;">
                    <strong style="color: #4fc1ff;">Pro Tip:</strong> Press <kbd>Ctrl+Shift+P</kbd> to open the Command Palette for quick access to all commands!
                </div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn primary" onclick="closeModal('shortcutsModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Command Palette Modal -->
    <div class="modal-overlay" id="commandPaletteModal" style="background: rgba(0,0,0,0.7);">
        <div class="modal" style="max-width: 600px; margin-top: 100px;">
            <div class="modal-title" style="padding: 15px 20px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 18px;">‚åò</span>
                    <span>Command Palette</span>
                </div>
            </div>
            <div style="padding: 0 20px 20px;">
                <input type="text" id="commandPaletteInput"
                    placeholder="Type a command..."
                    style="width: 100%; padding: 12px; background: #2a2a2a; border: 2px solid #4fc1ff; border-radius: 6px; color: #e0e0e0; font-size: 14px; outline: none;"
                    oninput="filterCommands()"
                    onkeydown="handleCommandPaletteKey(event)">
                <div id="commandPaletteResults" style="max-height: 400px; overflow-y: auto; margin-top: 10px;">
                    <!-- Commands will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Copy Python Modal -->
    <div class="modal-overlay" id="copyPythonModal">
        <div class="modal" style="max-width: 800px; max-height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-title">üêç Python SDK Code</div>
            <div class="modal-body" style="overflow-y: auto; flex: 1;">
                <p style="color: #d4d4d4; margin-bottom: 15px;">
                    Choose how you want to load and use this tree in Python:
                </p>

                <div style="display: grid; gap: 15px; margin-bottom: 20px;">
                    <!-- Option 1: From File -->
                    <div style="background: #2d2d30; border: 2px solid #3e3e42; border-radius: 6px; padding: 15px; cursor: pointer; transition: all 0.2s;"
                        onclick="selectPythonOption('file', this)" onmouseenter="this.style.borderColor='#4fc1ff'"
                        onmouseleave="if(!this.classList.contains('selected')) this.style.borderColor='#3e3e42'">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                            <span style="font-size: 24px;">üìÑ</span>
                            <strong style="color: #4fc1ff; font-size: 15px;">Load from JSON File</strong>
                        </div>
                        <p style="color: #888; font-size: 13px; margin: 0; line-height: 1.5;">
                            Export tree as JSON file, then load it in Python. Best for local development and version
                            control.
                        </p>
                    </div>

                    <!-- Option 2: From API -->
                    <div style="background: #2d2d30; border: 2px solid #3e3e42; border-radius: 6px; padding: 15px; cursor: pointer; transition: all 0.2s;"
                        onclick="selectPythonOption('api', this)" onmouseenter="this.style.borderColor='#4fc1ff'"
                        onmouseleave="if(!this.classList.contains('selected')) this.style.borderColor='#3e3e42'">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                            <span style="font-size: 24px;">‚òÅÔ∏è</span>
                            <strong style="color: #4fc1ff; font-size: 15px;">Save to API & Load from Server</strong>
                        </div>
                        <p style="color: #888; font-size: 13px; margin: 0; line-height: 1.5;">
                            Save tree to TalkingTrees API, then load it from the server. Best for shared/collaborative
                            environments.
                        </p>
                    </div>
                </div>

                <!-- Generated Code Display -->
                <div id="pythonCodeDisplay"
                    style="display: none; background: #1e1e1e; border: 1px solid #3e3e42; border-radius: 4px; padding: 15px; margin-top: 15px;">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="color: #4fc1ff;">Python Code:</strong>
                        <button onclick="copyGeneratedPythonCode(event)"
                            style="background: #16825d; border: none; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            üìã Copy to Clipboard
                        </button>
                    </div>
                    <pre id="generatedPythonCode"
                        style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border: 1px solid #3e3e42; border-radius: 4px; font-family: 'Monaco', 'Menlo', 'Consolas', monospace; font-size: 12px; line-height: 1.6; overflow-x: auto; overflow-y: auto; max-height: 400px; margin: 0; white-space: pre-wrap; word-wrap: break-word;"></pre>
                </div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="closeModal('copyPythonModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item has-submenu" id="addChildMenuItem">
            <span>‚ûï</span> Add Child
            <span style="margin-left: auto; opacity: 0.6;">‚ñ∂</span>
            <div class="context-submenu" id="addChildSubmenu" style="display: none;">
                <div class="context-menu-header">Common Nodes</div>
                <div class="context-menu-item" onclick="addChildNode('Sequence')">
                    <span>‚Üí</span> Sequence
                </div>
                <div class="context-menu-item" onclick="addChildNode('Selector')">
                    <span>?</span> Selector
                </div>
                <div class="context-menu-item" onclick="addChildNode('Parallel')">
                    <span>‚ö°</span> Parallel
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-header">Decorators</div>
                <div class="context-menu-item" onclick="addChildNode('Inverter')">
                    <span>¬¨</span> Inverter
                </div>
                <div class="context-menu-item" onclick="addChildNode('Retry')">
                    <span>‚Üª</span> Retry
                </div>
                <div class="context-menu-item" onclick="addChildNode('Timeout')">
                    <span>‚è±</span> Timeout
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-header">Actions</div>
                <div class="context-menu-item" onclick="addChildNode('Success')">
                    <span>‚úì</span> Success
                </div>
                <div class="context-menu-item" onclick="addChildNode('Failure')">
                    <span>‚úó</span> Failure
                </div>
                <div class="context-menu-item" onclick="addChildNode('Wait')">
                    <span>‚è≥</span> Wait
                </div>
                <div class="context-menu-item" onclick="addChildNode('SetBlackboardVariable')">
                    <span>‚úç</span> Set Variable
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-header">Conditions</div>
                <div class="context-menu-item" onclick="addChildNode('CheckBlackboardVariableValue')">
                    <span>üîç</span> Check Variable
                </div>
                <div class="context-menu-item" onclick="addChildNode('CheckBlackboardVariableExists')">
                    <span>üìå</span> Variable Exists
                </div>
            </div>
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="contextMenuAction('copy')">
            <span>üìã</span> Copy
            <span class="context-menu-shortcut">Ctrl+C</span>
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('cut')">
            <span>‚úÇÔ∏è</span> Cut
            <span class="context-menu-shortcut">Ctrl+X</span>
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('paste')">
            <span>üìÑ</span> Paste
            <span class="context-menu-shortcut">Ctrl+V</span>
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('duplicate')">
            <span>üìë</span> Duplicate
            <span class="context-menu-shortcut">Ctrl+D</span>
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="contextMenuAction('delete')">
            <span>üóëÔ∏è</span> Delete
            <span class="context-menu-shortcut">Del</span>
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="contextMenuAction('selectAll')">
            <span>‚òëÔ∏è</span> Select All
            <span class="context-menu-shortcut">Ctrl+A</span>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = 'http://localhost:8000';
        const STORAGE_KEY_LIBRARY = 'talkingtrees_tree_library';
        const STORAGE_KEY_CURRENT = 'talkingtrees_current_tree';
        const LIBRARY_VERSION = '3.0'; // Increment to force reload demos

        // State
        let nodes = [];
        let selectedNode = null;
        let selectedNodes = new Set(); // Multi-select
        let clipboard = null; // For copy/paste
        let searchResults = new Set(); // Nodes matching search
        let lastKeyTime = 0; // For double-key detection
        let lastKey = null;
        let nextNodeId = 1;
        let canvas, ctx, minimap, minimapCtx;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let connectMode = false;
        let connectFromNode = null;
        let currentTreeName = "Untitled Tree";
        let currentTreeId = null;
        let showGrid = false;

        // Pan & Zoom
        let viewportX = 0;
        let viewportY = 0;
        let viewportScale = 1.0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let isSpacePressed = false; // For Space+Drag panning

        // Drag detection
        let mouseDownPos = { x: 0, y: 0 };
        let hasMovedMouse = false;
        const DRAG_THRESHOLD = 5; // pixels before drag starts
        let dragTargetNode = null; // Node being hovered over during drag (for drag-to-connect)

        // Undo/Redo
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Enum options for dropdown selectors
        const ENUM_OPTIONS = {
            'operator': ['<', '<=', '==', '!=', '>=', '>'],
            'operator_str': ['<', '<=', '==', '!=', '>=', '>'],
            'policy': ['SuccessOnAll', 'SuccessOnOne'],
            'oneshot_policy': ['ON_COMPLETION', 'ON_SUCCESSFUL_COMPLETION'],
            'final_status': ['SUCCESS', 'FAILURE'],
            'eventually': ['null', 'SUCCESS', 'FAILURE', 'RUNNING'],
            'logical_operator': ['and', 'or']
        };

        // Node type icons for better visual recognition
        const NODE_ICONS = {
            // Composites
            'Sequence': '‚Üí',
            'Selector': '?',
            'Parallel': '‚ö°',

            // Decorators - Status Converters
            'Inverter': '¬¨',
            'SuccessIsFailure': '‚áÖ',
            'FailureIsSuccess': '‚áÖ',
            'FailureIsRunning': '‚ü≥',
            'RunningIsFailure': '‚ü≥',
            'RunningIsSuccess': '‚ü≥',
            'SuccessIsRunning': '‚ü≥',
            'PassThrough': '‚Üí',

            // Decorators - Control Flow
            'Retry': '‚Üª',
            'Repeat': '‚àû',
            'OneShot': '1',
            'Timeout': '‚è±',
            'EternalGuard': 'üëÅ',
            'Condition': '‚ùì',
            'Count': '#',
            'StatusToBlackboard': 'üìù',

            // Actions - Basic
            'Success': '‚úì',
            'Failure': '‚úó',
            'Running': '‚ü≥',
            'Dummy': '‚óã',

            // Actions - Time-based
            'Wait': '‚è≥',
            'TickCounter': 'üî¢',
            'SuccessEveryN': '‚ö°',
            'Periodic': 'üîÑ',
            'StatusQueue': 'üìã',

            // Actions - Blackboard
            'SetBlackboardVariable': '‚úç',
            'CheckBlackboardVariableValue': 'üîç',
            'CheckBlackboardVariableExists': 'üìå',
            'UnsetBlackboardVariable': 'üóë',

            // Actions - Debug
            'PrintBlackboard': 'üñ®',
            'PrintStatus': 'üìÑ',

            // Default
            'default': '‚óè'
        };

        // Comprehensive node type descriptions for tooltips
        const NODE_DESCRIPTIONS = {
            // Composites
            'Sequence': 'Executes children in order until one fails or all succeed. Useful for step-by-step tasks.',
            'Selector': 'Executes children in order until one succeeds or all fail. Useful for fallback behaviors.',
            'Parallel': 'Executes all children concurrently. Success policy determines when the parallel succeeds/fails.',

            // Decorators - Status Converters
            'Inverter': 'Inverts child result: SUCCESS ‚Üî FAILURE. Useful for negating conditions.',
            'SuccessIsFailure': 'Converts SUCCESS to FAILURE. Leaves other statuses unchanged.',
            'FailureIsSuccess': 'Converts FAILURE to SUCCESS. Useful for optional tasks.',
            'FailureIsRunning': 'Converts FAILURE to RUNNING. Keeps trying on failure.',
            'RunningIsFailure': 'Converts RUNNING to FAILURE. Fails on non-immediate completion.',
            'RunningIsSuccess': 'Converts RUNNING to SUCCESS. Succeeds on any progress.',
            'SuccessIsRunning': 'Converts SUCCESS to RUNNING. Prevents tree from terminating early.',
            'PassThrough': 'Returns child status unchanged. Useful for monitoring.',

            // Decorators - Control Flow
            'Retry': 'Retries child on failure up to N times. Returns SUCCESS if any attempt succeeds.',
            'Repeat': 'Repeats child on success up to N times. Useful for repeated actions.',
            'OneShot': 'Executes child only once, then returns cached result. Useful for initialization.',
            'Timeout': 'Fails if child runs longer than duration. Prevents hanging behaviors.',
            'EternalGuard': 'Only runs child if blackboard condition is met, checks every tick.',
            'Condition': 'Runs child only if blackboard condition is true. Checks once at start.',
            'Count': 'Counts how many times child succeeds. Stores count on blackboard.',
            'StatusToBlackboard': 'Writes child status to blackboard variable.',

            // Actions - Basic Status
            'Success': 'Always returns SUCCESS. Useful for testing or placeholder.',
            'Failure': 'Always returns FAILURE. Useful for testing or forced failure.',
            'Running': 'Always returns RUNNING. Useful for testing or keeping tree active.',
            'Dummy': 'Does nothing, returns SUCCESS. Useful for placeholder nodes.',

            // Actions - Time-based
            'Wait': 'Waits for specified duration, then returns SUCCESS.',
            'TickCounter': 'Returns RUNNING for N ticks, then returns final status.',
            'SuccessEveryN': 'Returns SUCCESS every N ticks, otherwise FAILURE.',
            'Periodic': 'Cycles through SUCCESS/RUNNING every N ticks.',
            'StatusQueue': 'Returns statuses from a queue in sequence.',

            // Actions - Blackboard
            'SetBlackboardVariable': 'Sets a variable on the blackboard to a specific value.',
            'GetBlackboardVariable': 'Reads a variable from the blackboard. Returns FAILURE if missing.',
            'UnsetBlackboardVariable': 'Removes a variable from the blackboard.',
            'BlackboardToStatus': 'Converts blackboard variable value to node status.',

            // Actions - Utilities
            'Log': 'Logs a message to console. Returns SUCCESS.',
            'CheckBlackboardCondition': 'Checks if blackboard variable meets condition. Returns SUCCESS/FAILURE.',

            // Conditions
            'CheckBlackboardVariableExists': 'Returns SUCCESS if variable exists on blackboard.',
            'WaitForBlackboardVariable': 'Returns RUNNING until variable exists on blackboard.',
            'WaitForBlackboardVariableValue': 'Returns RUNNING until variable matches expected value.',
            'CheckBlackboardVariableValue': 'Returns SUCCESS if variable matches expected value.',
            'CheckBlackboardVariableValues': 'Checks multiple blackboard conditions with AND/OR logic.',

            // Probabilistic
            'ProbabilisticBehaviour': 'Randomly chooses between behaviors based on weights.',

            // Custom
            // Default
            'default': 'Behavior tree node. Hover for more details.'
        };

        // Node Definitions (40+ node types)
        const NODE_DEFS = {
            // ===== COMPOSITES (3) =====
            'Sequence': { category: 'composite', canHaveChildren: true, maxChildren: -1, config: { memory: true } },
            'Selector': { category: 'composite', canHaveChildren: true, maxChildren: -1, config: { memory: false } },
            'Parallel': { category: 'composite', canHaveChildren: true, maxChildren: -1, config: { policy: 'SuccessOnAll', synchronise: true } },

            // ===== DECORATORS (14) =====
            // Status Converters (7)
            'Inverter': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },
            'SuccessIsFailure': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },
            'FailureIsSuccess': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },
            'FailureIsRunning': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },
            'RunningIsFailure': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },
            'RunningIsSuccess': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },
            'SuccessIsRunning': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },
            'PassThrough': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },

            // Repetition & Control (3)
            'Retry': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: { num_failures: 3 } },
            'Repeat': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: { num_success: 2 } },
            'OneShot': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: { policy: 'ON_COMPLETION' } },

            // Conditionals & Monitoring (4)
            'Timeout': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: { duration: 5.0 } },
            'EternalGuard': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: { variable: 'condition', operator: '==', value: 0 } },
            'Condition': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: { variable: 'condition', operator: '==', value: 0 } },
            'Count': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: {} },
            'StatusToBlackboard': { category: 'decorator', canHaveChildren: true, maxChildren: 1, config: { variable: 'status' } },

            // ===== ACTIONS (13+) =====
            // Basic Status (4)
            'Success': { category: 'action', canHaveChildren: false, maxChildren: 0, config: {} },
            'Failure': { category: 'action', canHaveChildren: false, maxChildren: 0, config: {} },
            'Running': { category: 'action', canHaveChildren: false, maxChildren: 0, config: {} },
            'Dummy': { category: 'action', canHaveChildren: false, maxChildren: 0, config: {} },

            // Time-Based (5)
            'Wait': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { duration: 1.0 } },
            'TickCounter': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { num_ticks: 1, final_status: 'SUCCESS' } },
            'SuccessEveryN': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { n: 2 } },
            'Periodic': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { n: 3 } },
            'StatusQueue': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { queue: ['SUCCESS'], eventually: 'null' } },

            // Blackboard Operations (4)
            'SetBlackboardVariable': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { variable: 'result', value: '' } },
            'GetBlackboardVariable': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { variable: 'result' } },
            'UnsetBlackboardVariable': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { variable: 'var' } },
            'BlackboardToStatus': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { variable: 'status' } },

            // Utilities (2)
            'Log': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { message: 'Log message' } },
            'CheckBlackboardCondition': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { variable: 'value', operator_str: '==', value: 0 } },

            // ===== CONDITIONS (5) =====
            'CheckBlackboardVariableExists': { category: 'condition', canHaveChildren: false, maxChildren: 0, config: { variable: 'key' } },
            'WaitForBlackboardVariable': { category: 'condition', canHaveChildren: false, maxChildren: 0, config: { variable: 'var' } },
            'WaitForBlackboardVariableValue': { category: 'condition', canHaveChildren: false, maxChildren: 0, config: { variable: 'var', operator: '==', value: 0 } },
            'CheckBlackboardVariableValue': { category: 'condition', canHaveChildren: false, maxChildren: 0, config: { variable: 'var', operator: '==', value: 0 } },
            'CheckBlackboardVariableValues': { category: 'condition', canHaveChildren: false, maxChildren: 0, config: { checks: [], logical_operator: 'and' } },

            // ===== PROBABILISTIC (1) =====
            'ProbabilisticBehaviour': { category: 'action', canHaveChildren: false, maxChildren: 0, config: { weights: [1.0, 1.0, 1.0] } },

            // ===== CUSTOM (1+) =====
        };

        // Resize canvas to match container (CRITICAL FIX for viewport bugs)
        function resizeCanvas() {
            const canvasArea = document.getElementById('canvasArea');
            const rect = canvasArea.getBoundingClientRect();

            // Set canvas dimensions to match container
            canvas.width = rect.width;
            canvas.height = rect.height;

            render();
        }

        // Initialize
        window.addEventListener('load', () => {
            canvas = document.getElementById('treeCanvas');
            ctx = canvas.getContext('2d');
            minimap = document.getElementById('minimapCanvas');
            minimapCtx = minimap.getContext('2d');

            // Resize canvas to match container
            resizeCanvas();

            // Handle window resize
            window.addEventListener('resize', () => {
                resizeCanvas();
            });

            // Watch for minimap panel resize
            const minimapPanel = document.getElementById('minimapPanel');
            if (minimapPanel) {
                let resizeTimeout;
                const resizeObserver = new ResizeObserver((entries) => {
                    // Debounce to prevent feedback loop
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        for (let entry of entries) {
                            const rect = entry.contentRect;
                            const headerHeight = 28; // Header bar height
                            const newWidth = Math.max(150, Math.floor(rect.width));
                            const newHeight = Math.max(100, Math.floor(rect.height - headerHeight));

                            // Only update if size actually changed significantly
                            if (Math.abs(minimap.width - newWidth) > 5 || Math.abs(minimap.height - newHeight) > 5) {
                                minimap.width = newWidth;
                                minimap.height = newHeight;
                                renderMinimap();
                            }
                        }
                    }, 100);
                });
                resizeObserver.observe(minimapPanel);
            }

            setupDragAndDrop();
            setupCanvas();
            setupKeyboardShortcuts();
            loadLibrary();
            restoreLastSession();
            render();
        });

        // Setup Functions
        function setupDragAndDrop() {
            const canvasArea = document.getElementById('canvasArea');

            document.querySelectorAll('.node-item').forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('nodeType', item.dataset.type);
                });
            });

            canvasArea.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            canvasArea.addEventListener('drop', (e) => {
                e.preventDefault();
                const nodeType = e.dataTransfer.getData('nodeType');
                if (nodeType) {
                    const rect = canvasArea.getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    const x = (canvasX - viewportX) / viewportScale;
                    const y = (canvasY - viewportY) / viewportScale;
                    createNode(nodeType, x, y);
                }
            });
        }

        function setupCanvas() {
            // Mouse wheel for zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                // Shift+Wheel for horizontal scrolling
                if (e.shiftKey) {
                    viewportX -= e.deltaY * 0.5; // Scroll horizontally
                    render();
                    return;
                }

                // Normal wheel for zoom
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.1, Math.min(5.0, viewportScale * zoomFactor));

                // Zoom toward cursor position
                const worldX = (mouseX - viewportX) / viewportScale;
                const worldY = (mouseY - viewportY) / viewportScale;

                viewportX = mouseX - worldX * newScale;
                viewportY = mouseY - worldY * newScale;
                viewportScale = newScale;

                updateZoomDisplay();
                render();
            });

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                const x = (canvasX - viewportX) / viewportScale;
                const y = (canvasY - viewportY) / viewportScale;

                const clickedNode = getNodeAt(x, y);

                // Panning (Space+drag, middle mouse, Ctrl+drag, or right mouse)
                if (isSpacePressed || e.button === 1 || (e.button === 0 && e.ctrlKey) || e.button === 2) {
                    e.preventDefault();
                    isPanning = true;
                    isDragging = false; // Ensure dragging is off
                    minimap.style.pointerEvents = 'auto'; // Re-enable minimap
                    panStart = { x: e.clientX - viewportX, y: e.clientY - viewportY };
                    canvas.style.cursor = 'grabbing';
                    return;
                }

                // Collapse toggle - check FIRST, before ANY state changes
                if (clickedNode && clickedNode.children.length > 0 && !connectMode) {
                    const badgeX = clickedNode.x + 140;
                    const badgeY = clickedNode.y + 10;
                    const dist = Math.sqrt((x - badgeX) ** 2 + (y - badgeY) ** 2);
                    if (dist < 30) { // VERY large hit area - 30px radius (almost 3x visual size)
                        e.preventDefault();
                        e.stopPropagation();
                        clickedNode.collapsed = !clickedNode.collapsed;
                        // DO NOT set any drag state
                        // DO NOT set mouseDownPos
                        // DO NOT select node
                        // Clear any existing drag state just to be safe
                        isDragging = false;
                        mouseDownPos = { x: 0, y: 0 };
                        hasMovedMouse = false;
                        canvas.style.cursor = 'default';
                        minimap.style.pointerEvents = 'auto'; // Re-enable minimap
                        saveHistory();
                        render();
                        updateStatus(`${clickedNode.collapsed ? 'Collapsed' : 'Expanded'} ${clickedNode.name}`);
                        return; // Exit immediately without setting ANY other state
                    }
                }

                // Connect mode handling
                if (connectMode && clickedNode) {
                    if (!connectFromNode) {
                        // First click - select parent
                        const def = NODE_DEFS[clickedNode.type];
                        if (def.canHaveChildren) {
                            connectFromNode = clickedNode;
                            updateStatus(`Selected ${clickedNode.name} - Now click child node to connect`);
                            render();
                        } else {
                            updateStatus(`${clickedNode.type} cannot have children`);
                        }
                    } else {
                        // Second click - connect child
                        if (clickedNode !== connectFromNode) {
                            connectNodes(connectFromNode, clickedNode);
                            connectFromNode = null;
                            updateStatus('Nodes connected! Click another parent or exit Connect Mode');
                        } else {
                            updateStatus('Cannot connect node to itself');
                        }
                        render();
                    }
                    return;
                }

                // Regular node interaction (not in connect mode)
                if (clickedNode && !connectMode) {
                    // If already dragging, clicking should STOP the drag, not start a new one
                    if (isDragging) {
                        isDragging = false;
                        hasMovedMouse = false;
                        mouseDownPos = { x: 0, y: 0 };
                        dragTargetNode = null;
                        canvas.style.cursor = 'default';
                        minimap.style.pointerEvents = 'auto';
                        render();
                        return;
                    }

                    // Support multi-select with Shift+Click
                    selectNode(clickedNode, e.shiftKey);

                    // Set up potential drag - but only START dragging after threshold
                    // Only allow dragging if single node selected (not multi-select)
                    if (!e.shiftKey || selectedNodes.size === 1) {
                        mouseDownPos = { x: e.clientX, y: e.clientY };
                        hasMovedMouse = false;
                        dragOffset = { x: x - clickedNode.x, y: y - clickedNode.y };
                    }
                } else if (!connectMode) {
                    // If already dragging, clicking empty space should STOP the drag
                    if (isDragging) {
                        isDragging = false;
                        hasMovedMouse = false;
                        mouseDownPos = { x: 0, y: 0 };
                        dragTargetNode = null;
                        canvas.style.cursor = 'default';
                        minimap.style.pointerEvents = 'auto';
                        render();
                        return;
                    }

                    // Clicked empty space - clear all selections
                    selectedNode = null;
                    selectedNodes.clear();
                    showProperties(null);
                    render();
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    viewportX = e.clientX - panStart.x;
                    viewportY = e.clientY - panStart.y;
                    render();
                    return;
                }

                // Get world coordinates for hover detection
                const rect = canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                const worldX = (canvasX - viewportX) / viewportScale;
                const worldY = (canvasY - viewportY) / viewportScale;

                // Check if hovering over collapse badge
                let overBadge = false;
                if (!isDragging) {
                    const hoveredNode = getNodeAt(worldX, worldY);
                    if (hoveredNode && hoveredNode.children.length > 0) {
                        const badgeX = hoveredNode.x + 140;
                        const badgeY = hoveredNode.y + 10;
                        const dist = Math.sqrt((worldX - badgeX) ** 2 + (worldY - badgeY) ** 2);
                        if (dist < 30) {
                            overBadge = true;
                            canvas.style.cursor = 'pointer';
                        }
                    }
                    if (!overBadge && canvas.style.cursor === 'pointer') {
                        canvas.style.cursor = 'default';
                    }
                }

                // Check for node hover (for tooltips)
                if (!isDragging && !isPanning) {
                    const nodeAtMouse = getNodeAt(worldX, worldY);

                    if (nodeAtMouse !== hoveredNode) {
                        hoveredNode = nodeAtMouse;
                        clearTimeout(tooltipTimeout);
                        hideNodeTooltip();

                        if (hoveredNode) {
                            tooltipTimeout = setTimeout(() => {
                                showNodeTooltip(hoveredNode, e.clientX, e.clientY);
                            }, 500); // Show after 500ms hover
                        }
                    } else if (hoveredNode) {
                        // Update tooltip position if still hovering
                        const tooltip = document.getElementById('nodeTooltip');
                        if (tooltip && tooltip.style.display === 'block') {
                            tooltip.style.left = (e.clientX + 15) + 'px';
                            tooltip.style.top = (e.clientY + 15) + 'px';
                        }
                    }
                }

                // Check if we should start dragging (threshold exceeded)
                if (selectedNode && !isDragging && !hasMovedMouse && mouseDownPos.x !== 0) {
                    const deltaX = e.clientX - mouseDownPos.x;
                    const deltaY = e.clientY - mouseDownPos.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                    if (distance > DRAG_THRESHOLD) {
                        hasMovedMouse = true;
                        isDragging = true;
                        canvas.style.cursor = 'grabbing';
                        // Hide tooltip when dragging starts
                        clearTimeout(tooltipTimeout);
                        hideNodeTooltip();
                        hoveredNode = null;
                        // Disable minimap pointer events during drag
                        minimap.style.pointerEvents = 'none';
                    }
                }

                // Perform dragging
                if (isDragging && selectedNode) {
                    if (showGrid) {
                        selectedNode.x = Math.round((worldX - dragOffset.x) / 50) * 50;
                        selectedNode.y = Math.round((worldY - dragOffset.y) / 50) * 50;
                    } else {
                        selectedNode.x = worldX - dragOffset.x;
                        selectedNode.y = worldY - dragOffset.y;
                    }

                    // Check if dragging over another node (for drag-to-connect)
                    dragTargetNode = null;
                    const hoveredNode = getNodeAt(worldX, worldY);
                    if (hoveredNode && hoveredNode !== selectedNode) {
                        // Check if hoveredNode can be a parent
                        const def = NODE_DEFS[hoveredNode.type];
                        if (def.canHaveChildren) {
                            // Check if we're not creating a cycle
                            const wouldCreateCycle = (potentialChild, potentialParent) => {
                                let ancestor = potentialParent;
                                while (ancestor) {
                                    if (ancestor === potentialChild) return true;
                                    ancestor = ancestor.parent;
                                }
                                return false;
                            };

                            if (!wouldCreateCycle(selectedNode, hoveredNode)) {
                                // Check max children limit
                                if (def.maxChildren === -1 || hoveredNode.children.length < def.maxChildren) {
                                    dragTargetNode = hoveredNode;
                                }
                            }
                        }
                    }

                    render();
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (isDragging && selectedNode) {
                    // Check if dropping on a valid connection target
                    if (dragTargetNode) {
                        connectNodes(dragTargetNode, selectedNode);
                        updateStatus(`‚úì Connected ${selectedNode.name} to ${dragTargetNode.name}`);
                    }
                    saveHistory();
                }
                // Clear all dragging/panning states
                isDragging = false;
                isPanning = false;
                hasMovedMouse = false;
                mouseDownPos = { x: 0, y: 0 };
                dragTargetNode = null;
                canvas.style.cursor = connectMode ? 'crosshair' : 'default';
                // Re-enable minimap pointer events
                minimap.style.pointerEvents = 'auto';
                render();
            });

            // Global mouseup to catch releases outside canvas
            document.addEventListener('mouseup', (e) => {
                // Check if we need to render (before clearing states)
                const needsRender = isDragging || isPanning || hasMovedMouse || dragTargetNode;

                // Handle drag completion if we were dragging
                if (isDragging && selectedNode) {
                    // Check if dropping on a valid connection target
                    if (dragTargetNode) {
                        connectNodes(dragTargetNode, selectedNode);
                        updateStatus(`‚úì Connected ${selectedNode.name} to ${dragTargetNode.name}`);
                    }
                    saveHistory();
                }

                // ALWAYS clear all dragging/panning states on any mouseup
                // This prevents stuck drag states when clicking without moving
                isDragging = false;
                isPanning = false;
                hasMovedMouse = false;
                mouseDownPos = { x: 0, y: 0 };
                dragTargetNode = null;
                canvas.style.cursor = connectMode ? 'crosshair' : 'default';
                // Re-enable minimap pointer events
                minimap.style.pointerEvents = 'auto';

                // Only render if we were actually in a drag/pan state
                if (needsRender) {
                    render();
                }
            });

            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();

                // Clear any drag states when right-clicking
                isDragging = false;
                isPanning = false;
                hasMovedMouse = false;
                mouseDownPos = { x: 0, y: 0 };
                dragTargetNode = null;
                canvas.style.cursor = connectMode ? 'crosshair' : 'default';
                // Re-enable minimap pointer events
                minimap.style.pointerEvents = 'auto';

                showContextMenu(e.clientX, e.clientY);
            });

            // Double-click to rename
            canvas.addEventListener('dblclick', (e) => {
                const rect = canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                const worldX = (canvasX - viewportX) / viewportScale;
                const worldY = (canvasY - viewportY) / viewportScale;

                const clickedNode = getNodeAt(worldX, worldY);
                if (clickedNode) {
                    startInlineRename(clickedNode, canvasX, canvasY);
                }
            });

            // Hide tooltip when mouse leaves canvas
            canvas.addEventListener('mouseleave', (e) => {
                clearTimeout(tooltipTimeout);
                hideNodeTooltip();
                hoveredNode = null;
            });

            // Minimap navigation
            minimap.addEventListener('click', (e) => {
                if (nodes.length === 0) return;

                const rect = minimap.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // Find bounds (same as renderMinimap)
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + 150);
                    maxY = Math.max(maxY, node.y + 60);
                });

                const treeWidth = maxX - minX + 400;
                const treeHeight = maxY - minY + 400;
                const scaleX = minimap.width / treeWidth;
                const scaleY = minimap.height / treeHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9;

                const offsetX = (minimap.width - (treeWidth * scale)) / 2;
                const offsetY = (minimap.height - (treeHeight * scale)) / 2;

                // Convert minimap click to world coordinates
                const worldX = ((clickX - offsetX) / scale) + minX - 200;
                const worldY = ((clickY - offsetY) / scale) + minY - 200;

                // Center main viewport on clicked world position
                viewportX = (canvas.width / 2) - (worldX * viewportScale);
                viewportY = (canvas.height / 2) - (worldY * viewportScale);

                render();
                updateStatus(`Navigated to position`);
            });

            minimap.style.cursor = 'pointer';

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (connectMode) {
                        toggleConnectMode(); // Exit connect mode
                    }
                }
            });

            // Global click handler to close context menu
            document.addEventListener('click', (e) => {
                const contextMenu = document.getElementById('contextMenu');
                if (!contextMenu.contains(e.target)) {
                    contextMenu.classList.remove('active');
                }
            });
        }

        // Context Menu Functions
        function showContextMenu(x, y) {
            const contextMenu = document.getElementById('contextMenu');

            // Position the menu at cursor
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';

            // Update menu items based on current state
            updateContextMenuState();

            // Show menu
            contextMenu.classList.add('active');
        }

        function updateContextMenuState() {
            const hasSelection = selectedNodes.size > 0;
            const hasClipboard = clipboard !== null;

            // Check if selected node can have children
            let canAddChild = false;
            if (selectedNode) {
                const parentDef = NODE_DEFS[selectedNode.type];
                canAddChild = parentDef && parentDef.canHaveChildren &&
                    (parentDef.maxChildren < 0 || selectedNode.children.length < parentDef.maxChildren);
            }

            // Enable/disable "Add Child" menu item
            const addChildMenuItem = document.getElementById('addChildMenuItem');
            if (addChildMenuItem) {
                if (canAddChild) {
                    addChildMenuItem.classList.remove('disabled');
                } else {
                    addChildMenuItem.classList.add('disabled');
                }
            }

            // Enable/disable menu items based on state
            const items = document.querySelectorAll('.context-menu-item');
            items.forEach(item => {
                const action = item.getAttribute('onclick');
                if (!action) return;

                // Disable copy/cut/duplicate/delete if no selection
                if (action.includes('copy') || action.includes('cut') ||
                    action.includes('duplicate') || action.includes('delete')) {
                    if (hasSelection) {
                        item.classList.remove('disabled');
                    } else {
                        item.classList.add('disabled');
                    }
                }

                // Disable paste if no clipboard
                if (action.includes('paste')) {
                    if (hasClipboard) {
                        item.classList.remove('disabled');
                    } else {
                        item.classList.add('disabled');
                    }
                }
            });
        }

        function contextMenuAction(action) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.classList.remove('active');

            switch (action) {
                case 'copy':
                    if (selectedNodes.size > 0) copySelected();
                    break;
                case 'cut':
                    if (selectedNodes.size > 0) cutSelected();
                    break;
                case 'paste':
                    if (clipboard) pasteFromClipboard();
                    break;
                case 'duplicate':
                    if (selectedNodes.size > 0) duplicateSelected();
                    break;
                case 'delete':
                    if (selectedNodes.size > 0) deleteSelectedNodes();
                    break;
                case 'selectAll':
                    selectAll();
                    break;
            }
        }

        // Add child node to selected node
        function addChildNode(nodeType) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.classList.remove('active');

            if (!selectedNode) {
                showToast('Please select a parent node first', 'warning');
                return;
            }

            const nodeDef = NODE_DEFS[nodeType];
            if (!nodeDef) {
                showToast('Unknown node type: ' + nodeType, 'error');
                return;
            }

            // Check if parent can have children
            const parentDef = NODE_DEFS[selectedNode.type];
            if (!parentDef.canHaveChildren) {
                showToast(`${selectedNode.type} nodes cannot have children`, 'warning');
                return;
            }

            // Check if parent has reached max children
            if (parentDef.maxChildren > 0 && selectedNode.children.length >= parentDef.maxChildren) {
                showToast(`${selectedNode.type} can only have ${parentDef.maxChildren} child(ren)`, 'warning');
                return;
            }

            // Create the new child node
            const newNode = {
                id: nextNodeId++,
                type: nodeType,
                category: nodeDef.category,
                name: nodeType,
                x: selectedNode.x + 50,
                y: selectedNode.y + (selectedNode.children.length * 100) + 100,
                config: JSON.parse(JSON.stringify(nodeDef.config)), // Deep copy config
                children: [],
                parent: { id: selectedNode.id },
                collapsed: false
            };

            // Add to nodes array
            nodes.push(newNode);

            // Add to parent's children
            selectedNode.children.push({ id: newNode.id });

            // Auto-layout to position nicely
            autoLayoutTree();

            // Select the new node
            selectNode(newNode);

            render();
            saveHistory();
            showToast(`Added ${nodeType} as child of ${selectedNode.name}`, 'success');
        }

        // Inline rename functionality
        function startInlineRename(node, canvasX, canvasY) {
            // Remove any existing rename input
            const existingInput = document.getElementById('inlineRenameInput');
            if (existingInput) {
                existingInput.remove();
            }

            // Create input overlay
            const input = document.createElement('input');
            input.id = 'inlineRenameInput';
            input.type = 'text';
            input.value = node.name;
            input.style.position = 'absolute';
            input.style.left = canvasX + 'px';
            input.style.top = canvasY + 'px';
            input.style.width = '140px';
            input.style.padding = '4px 8px';
            input.style.background = '#3c3c3c';
            input.style.border = '2px solid #4fc1ff';
            input.style.borderRadius = '3px';
            input.style.color = '#ffffff';
            input.style.fontSize = '13px';
            input.style.fontFamily = 'Segoe UI, sans-serif';
            input.style.zIndex = '10000';
            input.style.outline = 'none';

            const canvasArea = document.getElementById('canvasArea');
            canvasArea.appendChild(input);

            // Select all text
            input.select();
            input.focus();

            // Save on Enter or blur
            const saveRename = () => {
                const newName = input.value.trim();
                if (newName && newName !== node.name) {
                    node.name = newName;
                    saveHistory();
                    updateStatus(`‚úì Renamed to "${newName}"`);
                    showProperties(node);
                }
                input.remove();
                render();
            };

            // Cancel on Escape
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    input.remove();
                    render();
                }
            });

            input.addEventListener('blur', saveRename);
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore keyboard shortcuts when typing in input fields or textareas
                const activeElement = document.activeElement;
                const isInputField = activeElement && (
                    activeElement.tagName === 'INPUT' ||
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.isContentEditable
                );

                // Space key for pan mode (hold Space + drag to pan)
                if (e.key === ' ' && !isInputField && !isSpacePressed) {
                    isSpacePressed = true;
                    canvas.style.cursor = 'grab';
                    // Don't prevent default yet - we'll handle collapse on keyup if not panning
                    return;
                }

                // Allow Escape to work even in input fields
                if (e.key === 'Escape' && isInputField) {
                    activeElement.blur();
                    return;
                }

                // Skip all other shortcuts if in input field (except Ctrl+F)
                if (isInputField && !(e.ctrlKey && e.key.toLowerCase() === 'f')) {
                    return;
                }

                // Ctrl/Cmd shortcuts
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 'n':
                            e.preventDefault();
                            newTree();
                            break;
                        case 's':
                            e.preventDefault();
                            saveToLibrary();
                            break;
                        case 'z':
                            e.preventDefault();
                            undo();
                            break;
                        case 'y':
                            e.preventDefault();
                            redo();
                            break;
                        case 'l':
                            e.preventDefault();
                            autoLayout();
                            break;
                        case 'g':
                            e.preventDefault();
                            toggleGrid();
                            break;
                        case '0':
                            e.preventDefault();
                            zoomFit();
                            break;
                        case 'c':
                            e.preventDefault();
                            if (e.shiftKey) {
                                // Ctrl+Shift+C = Copy node path
                                copyNodePath();
                            } else {
                                // Ctrl+C = Copy node
                                copySelected();
                            }
                            break;
                        case 'x':
                            e.preventDefault();
                            cutSelected();
                            break;
                        case 'v':
                            e.preventDefault();
                            if (e.shiftKey) {
                                // Ctrl+Shift+V = Validate
                                validateTree();
                            } else {
                                // Ctrl+V = Paste
                                pasteFromClipboard();
                            }
                            break;
                        case 'd':
                            e.preventDefault();
                            duplicateSelected();
                            break;
                        case 'f':
                            e.preventDefault();
                            document.getElementById('nodeSearchInput').focus();
                            document.getElementById('nodeSearchInput').select();
                            updateStatus('Search focused - type to search nodes');
                            break;
                        case 'a':
                            e.preventDefault();
                            selectAll();
                            break;
                    }
                }

                // Delete key
                if (e.key === 'Delete') {
                    if (selectedNodes.size > 0) {
                        deleteSelectedNodes();
                    } else if (selectedNode) {
                        deleteSelectedNode();
                    }
                }

                // Double-D to delete (vim-style)
                if (e.key.toLowerCase() === 'd' && !e.ctrlKey && !e.metaKey) {
                    const now = Date.now();
                    if (lastKey === 'd' && (now - lastKeyTime) < 500) {
                        // Double-D pressed
                        if (selectedNodes.size > 0) {
                            deleteSelectedNodes();
                        } else if (selectedNode) {
                            deleteSelectedNode();
                        }
                        lastKey = null;
                    } else {
                        lastKey = 'd';
                        lastKeyTime = now;
                    }
                }

                // S key for connect mode toggle
                if (e.key.toLowerCase() === 's' && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    toggleConnectMode();
                }

                // F1 or ? for keyboard shortcuts reference
                if (e.key === 'F1' || e.key === '?') {
                    e.preventDefault();
                    document.getElementById('shortcutsModal').classList.add('active');
                }

                // Ctrl+Shift+P for command palette
                if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'p') {
                    e.preventDefault();
                    openCommandPalette();
                }

                // Zoom with +/-
                if (e.key === '+' || e.key === '=') {
                    e.preventDefault();
                    zoomIn();
                }
                if (e.key === '-' || e.key === '_') {
                    e.preventDefault();
                    zoomOut();
                }

                // Arrow key navigation
                if (selectedNode && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();

                    if (e.key === 'ArrowUp' && selectedNode.parent) {
                        // Select parent
                        const parentNode = nodes.find(n => n.id === selectedNode.parent.id);
                        if (parentNode) {
                            selectNode(parentNode, false);
                            centerViewOnNode(parentNode);
                            updateStatus(`‚Üë Selected parent: ${parentNode.name}`);
                        }
                    } else if (e.key === 'ArrowDown' && selectedNode.children.length > 0) {
                        // Select first child
                        const firstChildNode = nodes.find(n => n.id === selectedNode.children[0].id);
                        if (firstChildNode) {
                            selectNode(firstChildNode, false);
                            centerViewOnNode(firstChildNode);
                            updateStatus(`‚Üì Selected child: ${firstChildNode.name}`);
                        }
                    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        // Select sibling
                        if (selectedNode.parent) {
                            const parentNode = nodes.find(n => n.id === selectedNode.parent.id);
                            if (parentNode && parentNode.children) {
                                const currentIndex = parentNode.children.findIndex(c => c.id === selectedNode.id);

                                if (e.key === 'ArrowLeft' && currentIndex > 0) {
                                    const prevSiblingNode = nodes.find(n => n.id === parentNode.children[currentIndex - 1].id);
                                    if (prevSiblingNode) {
                                        selectNode(prevSiblingNode, false);
                                        centerViewOnNode(prevSiblingNode);
                                        updateStatus(`‚Üê Selected previous: ${prevSiblingNode.name}`);
                                    }
                                } else if (e.key === 'ArrowRight' && currentIndex < parentNode.children.length - 1) {
                                    const nextSiblingNode = nodes.find(n => n.id === parentNode.children[currentIndex + 1].id);
                                    if (nextSiblingNode) {
                                        selectNode(nextSiblingNode, false);
                                        centerViewOnNode(nextSiblingNode);
                                        updateStatus(`‚Üí Selected next: ${nextSiblingNode.name}`);
                                    }
                                }
                            }
                        }
                    }
                }

                // Enter to toggle collapse (Space is handled in keyup for pan mode compatibility)
                if (selectedNode && e.key === 'Enter') {
                    if (selectedNode.children.length > 0) {
                        e.preventDefault();
                        selectedNode.collapsed = !selectedNode.collapsed;
                        saveHistory();
                        render();
                        updateStatus(`${selectedNode.collapsed ? 'Collapsed' : 'Expanded'} ${selectedNode.name}`);
                    }
                }

                // F2 to rename
                if (e.key === 'F2' && selectedNode) {
                    e.preventDefault();
                    // Get screen position of selected node
                    const screenX = (selectedNode.x * viewportScale) + viewportX + 75;
                    const screenY = (selectedNode.y * viewportScale) + viewportY + 30;
                    startInlineRename(selectedNode, screenX, screenY);
                }

                // Backspace to disconnect node from parent (but don't delete it)
                if (e.key === 'Backspace' && selectedNode && selectedNode.parent) {
                    e.preventDefault();
                    disconnectNode(selectedNode);
                    updateStatus(`‚úì Disconnected ${selectedNode.name} from parent`);
                }

                // Tab to cycle through nodes
                if (e.key === 'Tab') {
                    e.preventDefault();
                    if (nodes.length > 0) {
                        if (!selectedNode) {
                            // Select first node
                            selectNode(nodes[0], false);
                        } else {
                            // Find current index and select next (or first if at end)
                            const currentIndex = nodes.indexOf(selectedNode);
                            const nextIndex = (currentIndex + 1) % nodes.length;
                            selectNode(nodes[nextIndex], false);
                            centerViewOnNode(nodes[nextIndex]);
                        }
                        updateStatus(`Tab: ${selectedNode.name}`);
                    }
                }

                // Home/End to navigate to first/last sibling
                if (selectedNode && selectedNode.parent && (e.key === 'Home' || e.key === 'End')) {
                    e.preventDefault();
                    const parentNode = nodes.find(n => n.id === selectedNode.parent.id);
                    if (parentNode && parentNode.children && parentNode.children.length > 0) {
                        if (e.key === 'Home') {
                            const firstSiblingNode = nodes.find(n => n.id === parentNode.children[0].id);
                            if (firstSiblingNode) {
                                selectNode(firstSiblingNode, false);
                                centerViewOnNode(firstSiblingNode);
                                updateStatus(`Home: ${firstSiblingNode.name}`);
                            }
                        } else if (e.key === 'End') {
                            const lastSiblingNode = nodes.find(n => n.id === parentNode.children[parentNode.children.length - 1].id);
                            if (lastSiblingNode) {
                                selectNode(lastSiblingNode, false);
                                centerViewOnNode(lastSiblingNode);
                                updateStatus(`End: ${lastSiblingNode.name}`);
                            }
                        }
                    }
                }

                // Shift+Arrow to swap sibling positions (reorder children)
                if (selectedNode && selectedNode.parent && e.shiftKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                    e.preventDefault();
                    const parentNode = nodes.find(n => n.id === selectedNode.parent.id);
                    if (parentNode && parentNode.children) {
                        const siblings = parentNode.children;
                        const currentIndex = siblings.findIndex(c => c.id === selectedNode.id);

                        if (e.key === 'ArrowLeft' && currentIndex > 0) {
                            // Swap with previous sibling
                            [siblings[currentIndex - 1], siblings[currentIndex]] = [siblings[currentIndex], siblings[currentIndex - 1]];
                            saveHistory();
                            render();
                            updateStatus(`‚áê Moved ${selectedNode.name} left`);
                        } else if (e.key === 'ArrowRight' && currentIndex < siblings.length - 1) {
                            // Swap with next sibling
                            [siblings[currentIndex], siblings[currentIndex + 1]] = [siblings[currentIndex + 1], siblings[currentIndex]];
                            saveHistory();
                            render();
                            updateStatus(`‚áí Moved ${selectedNode.name} right`);
                        }
                    }
                }

                // PageUp to navigate to root, PageDown to navigate to deepest visible child
                if (selectedNode && (e.key === 'PageUp' || e.key === 'PageDown')) {
                    e.preventDefault();
                    if (e.key === 'PageUp') {
                        // Navigate to root
                        let root = selectedNode;
                        while (root.parent) {
                            root = root.parent;
                        }
                        selectNode(root, false);
                        centerViewOnNode(root);
                        updateStatus(`Root: ${root.name}`);
                    } else if (e.key === 'PageDown') {
                        // Navigate to deepest child (keep going down first child)
                        let deepest = selectedNode;
                        while (deepest.children.length > 0 && !deepest.collapsed) {
                            deepest = deepest.children[0];
                        }
                        if (deepest !== selectedNode) {
                            selectNode(deepest, false);
                            centerViewOnNode(deepest);
                            updateStatus(`Deepest: ${deepest.name}`);
                        }
                    }
                }
            });

            // Space key release - restore cursor and handle collapse if not panning
            document.addEventListener('keyup', (e) => {
                if (e.key === ' ' && isSpacePressed) {
                    isSpacePressed = false;
                    // If we weren't panning, this was a quick Space press for collapse
                    if (!isPanning && selectedNode && selectedNode.children.length > 0) {
                        selectedNode.collapsed = !selectedNode.collapsed;
                        saveHistory();
                        render();
                        updateStatus(`${selectedNode.collapsed ? 'Collapsed' : 'Expanded'} ${selectedNode.name}`);
                    }
                    // Restore cursor
                    canvas.style.cursor = connectMode ? 'crosshair' : 'default';
                }
            });
        }

        // Node Management
        function createNode(type, x, y) {
            const def = NODE_DEFS[type];
            const node = {
                id: nextNodeId++,
                type: type,
                category: def.category,
                name: type,
                x: showGrid ? Math.round(x / 50) * 50 : x,
                y: showGrid ? Math.round(y / 50) * 50 : y,
                config: JSON.parse(JSON.stringify(def.config)),
                children: [],
                parent: null,
                collapsed: false
            };

            nodes.push(node);

            // Hide quick start hint after first node
            if (nodes.length === 1) {
                hideQuickStartHint();
            }

            selectNode(node);
            saveHistory();
            render();
            updateStatus(`‚úì Created ${type}`);
        }

        function connectNodes(parent, child) {
            if (child.parent) {
                updateStatus('Child already has a parent! Disconnect first.');
                return;
            }

            const def = NODE_DEFS[parent.type];
            if (def.maxChildren !== -1 && parent.children.length >= def.maxChildren) {
                updateStatus(`${parent.type} can only have ${def.maxChildren} child(ren)`);
                return;
            }

            parent.children.push({ id: child.id });
            child.parent = { id: parent.id };
            saveHistory();
            render();
            updateStatus(`Connected ${parent.name} ‚Üí ${child.name}`);
        }

        function disconnectNode(node) {
            if (!node.parent) {
                updateStatus('Node has no parent to disconnect from');
                return;
            }

            const parentNode = nodes.find(n => n.id === node.parent.id);
            if (!parentNode) {
                updateStatus('Parent node not found');
                return;
            }

            const parentName = parentNode.name;

            // Remove from parent's children array
            if (parentNode.children) {
                parentNode.children = parentNode.children.filter(c => c.id !== node.id);
            }

            // Clear parent reference
            node.parent = null;

            saveHistory();
            render();
            updateStatus(`‚úì Disconnected ${node.name} from ${parentName}`);
        }

        function selectNode(node, multiSelect = false) {
            if (multiSelect) {
                // Multi-select mode (Shift+Click)
                if (selectedNodes.has(node)) {
                    // Deselect if already selected
                    selectedNodes.delete(node);
                    if (node === selectedNode) {
                        // If removing primary selection, make another node primary
                        selectedNode = selectedNodes.size > 0 ? Array.from(selectedNodes)[0] : null;
                    }
                    updateStatus(`Deselected ${node.name} (${selectedNodes.size} nodes selected)`);
                } else {
                    // Add to selection
                    selectedNodes.add(node);
                    selectedNode = node; // Make this the primary selection
                    updateStatus(`Added ${node.name} to selection (${selectedNodes.size} nodes selected)`);
                }
            } else {
                // Single select mode (normal click)
                selectedNodes.clear();
                selectedNodes.add(node);
                selectedNode = node;
                updateStatus(`Selected ${node.name}`);
            }
            updateBreadcrumbPath(); // Update path display
            render();
            showProperties(selectedNode);
        }

        function getNodeAt(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (x >= node.x && x <= node.x + 150 &&
                    y >= node.y && y <= node.y + 60) {
                    return node;
                }
            }
            return null;
        }

        function deleteSelectedNode() {
            if (!selectedNode) return;

            if (selectedNode.parent) {
                const parentNode = nodes.find(n => n.id === selectedNode.parent.id);
                if (parentNode && parentNode.children) {
                    parentNode.children = parentNode.children.filter(c => c.id !== selectedNode.id);
                }
            }

            function deleteRecursive(node) {
                for (let childRef of node.children) {
                    const child = nodes.find(n => n.id === childRef.id);
                    if (child) deleteRecursive(child);
                }
                nodes = nodes.filter(n => n !== node);
            }
            deleteRecursive(selectedNode);

            selectedNode = null;
            saveHistory();
            showProperties(null);
            render();
            updateStatus('Node deleted');
        }

        function disconnectNode() {
            if (selectedNode && selectedNode.parent) {
                const parentNode = nodes.find(n => n.id === selectedNode.parent.id);
                if (parentNode && parentNode.children) {
                    parentNode.children = parentNode.children.filter(c => c.id !== selectedNode.id);
                }
                selectedNode.parent = null;
                saveHistory();
                showProperties(selectedNode);
                render();
                updateStatus('Node disconnected');
            }
        }

        // Properties Panel
        function showProperties(node) {
            const content = document.getElementById('propertiesContent');

            if (!node) {
                content.innerHTML = '<div style="color: #858585; text-align: center; padding: 40px 20px;">Select a node to edit its properties</div>';
                return;
            }

            const def = NODE_DEFS[node.type];
            let html = `
                <div class="prop-group">
                    <div class="prop-label">Node Type</div>
                    <input class="prop-input" value="${node.type}" disabled>
                </div>
                <div class="prop-group">
                    <div class="prop-label">Node Name</div>
                    <input class="prop-input" id="prop-name" value="${node.name}"
                           onchange="updateNodeProperty('name', this.value)">
                </div>
            `;

            // Configuration properties
            if (Object.keys(node.config).length > 0) {
                html += '<div class="section-title">Configuration</div>';

                for (let key in node.config) {
                    const value = node.config[key];
                    const labelText = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                    // Check if this is an enum property (has dropdown options)
                    if (key in ENUM_OPTIONS) {
                        const options = ENUM_OPTIONS[key];
                        html += `
                            <div class="prop-group">
                                <div class="prop-label">${labelText}</div>
                                <select class="prop-input" onchange="updateNodeConfig('${key}', this.value)">
                                    ${options.map(opt =>
                                        `<option value="${opt}" ${value == opt ? 'selected' : ''}>${opt}</option>`
                                    ).join('')}
                                </select>
                            </div>
                        `;
                    }
                    // Check if this is an array property
                    else if (Array.isArray(value)) {
                        const jsonValue = JSON.stringify(value, null, 2);
                        html += `
                            <div class="prop-group">
                                <div class="prop-label">${labelText}</div>
                                <textarea class="prop-input" rows="4"
                                          onchange="updateNodeConfigArray('${key}', this.value)"
                                          placeholder="Enter JSON array">${jsonValue}</textarea>
                                <div style="font-size: 10px; color: #858585; margin-top: 4px;">JSON array format</div>
                            </div>
                        `;
                    }
                    // Boolean checkbox
                    else if (typeof value === 'boolean') {
                        html += `
                            <div class="prop-group">
                                <div class="prop-checkbox">
                                    <input type="checkbox" ${value ? 'checked' : ''}
                                           onchange="updateNodeConfig('${key}', this.checked)"
                                           id="config-${key}">
                                    <label for="config-${key}">${labelText}</label>
                                </div>
                            </div>
                        `;
                    }
                    // Regular text/number input
                    else {
                        html += `
                            <div class="prop-group">
                                <div class="prop-label">${labelText}</div>
                                <input class="prop-input" value="${value}"
                                       onchange="updateNodeConfig('${key}', this.value)">
                            </div>
                        `;
                    }
                }
            }

            // Node info
            html += `
                <div class="section-title">Node Info</div>
                <div class="prop-group">
                    <div class="prop-label">Children Count</div>
                    <input class="prop-input" value="${node.children.length}" disabled>
                </div>
            `;

            if (node.parent) {
                const parentNode = nodes.find(n => n.id === node.parent.id);
                const parentName = parentNode ? parentNode.name : 'Unknown';
                html += `
                    <div class="prop-group">
                        <div class="prop-label">Parent Node</div>
                        <input class="prop-input" value="${parentName}" disabled>
                    </div>
                    <div class="prop-group">
                        <button class="prop-btn secondary" onclick="disconnectNode()">
                            Disconnect from Parent
                        </button>
                    </div>
                `;
            }

            html += `
                <div class="section-title">Actions</div>
                <div class="prop-group">
                    <button class="prop-btn danger" onclick="deleteSelectedNode()">
                        Delete Node (Del)
                    </button>
                </div>
            `;

            content.innerHTML = html;
        }

        function updateNodeProperty(prop, value) {
            if (selectedNode) {
                selectedNode[prop] = value;
                saveHistory();
                render();
            }
        }

        function updateNodeConfig(key, value) {
            if (selectedNode) {
                if (typeof value === 'string' && !isNaN(value) && value !== '') {
                    value = parseFloat(value);
                }
                selectedNode.config[key] = value;
                saveHistory();
                render();
            }
        }

        function updateNodeConfigArray(key, value) {
            if (selectedNode) {
                try {
                    const parsed = JSON.parse(value);
                    if (Array.isArray(parsed)) {
                        selectedNode.config[key] = parsed;
                        saveHistory();
                        render();
                        updateStatus('‚úì Array updated');
                    } else {
                        updateStatus('‚ùå Must be a valid JSON array');
                    }
                } catch (e) {
                    updateStatus('‚ùå Invalid JSON format: ' + e.message);
                }
            }
        }

        // Rendering
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid if enabled
            if (showGrid) {
                const canvasArea = document.getElementById('canvasArea');
                canvasArea.classList.add('canvas-grid');
            } else {
                const canvasArea = document.getElementById('canvasArea');
                canvasArea.classList.remove('canvas-grid');
            }

            ctx.save();
            ctx.translate(viewportX, viewportY);
            ctx.scale(viewportScale, viewportScale);

            function isNodeVisible(node) {
                let currentNode = node;
                while (currentNode.parent) {
                    const parentNode = nodes.find(n => n.id === currentNode.parent.id);
                    if (!parentNode) break;
                    if (parentNode.collapsed) return false;
                    currentNode = parentNode;
                }
                return true;
            }

            // Draw connections
            let connectionCount = 0;
            nodes.forEach(node => {
                if (!isNodeVisible(node)) return;
                if (node.collapsed) return;

                node.children.forEach(childRef => {
                    const child = nodes.find(n => n.id === childRef.id);
                    if (!child) return;

                    const fromX = node.x + 75;
                    const fromY = node.y + 60;
                    const toX = child.x + 75;
                    const toY = child.y;

                    // Calculate control point offset based on distance
                    const distance = Math.abs(toY - fromY);
                    const controlOffset = Math.min(distance * 0.4, 80); // Smooth, adaptive curve

                    // Add subtle shadow for depth
                    ctx.shadowColor = 'rgba(79, 193, 255, 0.3)';
                    ctx.shadowBlur = 4;

                    ctx.strokeStyle = '#4fc1ff';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);

                    // Improved bezier control points for more natural curve
                    const cp1x = fromX;
                    const cp1y = fromY + controlOffset;
                    const cp2x = toX;
                    const cp2y = toY - controlOffset;

                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toX, toY);
                    ctx.stroke();

                    // Reset shadow
                    ctx.shadowBlur = 0;

                    // Arrow with better proportions
                    ctx.fillStyle = '#4fc1ff';
                    ctx.beginPath();
                    ctx.moveTo(toX, toY);
                    ctx.lineTo(toX - 6, toY - 12);
                    ctx.lineTo(toX + 6, toY - 12);
                    ctx.closePath();
                    ctx.fill();

                    connectionCount++;
                });
            });

            // Draw connecting line in connect mode
            if (connectMode && connectFromNode) {
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(connectFromNode.x + 75, connectFromNode.y + 60);
                ctx.lineTo(connectFromNode.x + 75, connectFromNode.y + 100);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw nodes
            nodes.forEach(node => {
                if (!isNodeVisible(node)) return;

                const isSelected = selectedNodes.has(node);
                const isPrimarySelection = node === selectedNode;
                const isConnecting = connectMode && node === connectFromNode;
                const isConnectable = connectMode && !connectFromNode && NODE_DEFS[node.type].canHaveChildren;

                // Shadow for depth
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = isSelected ? 15 : 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;

                // Node box with gradient
                let gradient = ctx.createLinearGradient(node.x, node.y, node.x, node.y + 60);
                if (isConnecting) {
                    gradient.addColorStop(0, '#f39c12');
                    gradient.addColorStop(1, '#d68910');
                } else if (isSelected) {
                    gradient.addColorStop(0, '#4e4e52');
                    gradient.addColorStop(1, '#3a3a3e');
                } else {
                    gradient.addColorStop(0, '#37373d');
                    gradient.addColorStop(1, '#2d2d30');
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(node.x, node.y, 150, 60);

                // Add subtle inner highlight at top for 3D effect
                if (!isConnecting) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
                    ctx.fillRect(node.x, node.y, 150, 1);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(node.x, node.y + 1, 150, 1);
                }

                // Get simulation state for this node
                const simState = simulationState.nodeStates.get(node.id);
                if (simState && simState.status !== NodeStatus.IDLE) {
                    // Add status indicator
                    const statusColors = {
                        [NodeStatus.SUCCESS]: '#4caf50',
                        [NodeStatus.FAILURE]: '#f44336',
                        [NodeStatus.RUNNING]: '#ff9800',
                        [NodeStatus.IDLE]: 'transparent'
                    };

                    const statusColor = statusColors[simState.status] || 'transparent';

                    // Draw status border
                    if (statusColor !== 'transparent') {
                        ctx.strokeStyle = statusColor;
                        ctx.lineWidth = 4;
                        ctx.strokeRect(node.x, node.y, 150, 60);

                        // Draw status badge in corner
                        ctx.fillStyle = statusColor;
                        ctx.beginPath();
                        ctx.arc(node.x + 150 - 8, node.y + 8, 8, 0, Math.PI * 2);
                        ctx.fill();

                        // Tick count now shown in simulation control pane
                    }
                }

                // Reset text properties after simulation rendering
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;

                // Border with connect mode feedback and multi-select styling
                const isSearchResult = searchResults.has(node);
                const isDragTarget = node === dragTargetNode;
                let borderColor = '#3e3e42';
                // Thicker borders for composite nodes (visual hierarchy)
                let borderWidth = 2;
                if (node.category === 'composite') {
                    borderWidth = 3;
                } else if (node.category === 'decorator') {
                    borderWidth = 2;
                } else {
                    borderWidth = 1.5;
                }
                let useDashedBorder = false;

                if (isDragTarget) {
                    borderColor = '#27ae60'; // Green for valid drop target
                    borderWidth = 5;
                    // Add strong glow for drag target
                    ctx.shadowColor = 'rgba(39, 174, 96, 0.8)';
                    ctx.shadowBlur = 20;
                } else if (isConnecting) {
                    borderColor = '#f39c12'; // Orange for parent being connected
                    borderWidth = 4;
                } else if (isPrimarySelection && isSelected) {
                    borderColor = '#4fc1ff'; // Solid blue for primary selection
                    borderWidth = 3;
                } else if (isSelected) {
                    borderColor = '#4fc1ff'; // Blue for secondary selections
                    borderWidth = 2.5;
                    useDashedBorder = true; // Dashed border for secondary selections
                } else if (isSearchResult) {
                    borderColor = '#f1c40f'; // Yellow/gold for search results
                    borderWidth = 3;
                    // Add animated pulse effect for search results
                    const pulseAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 300);
                    ctx.shadowColor = `rgba(241, 196, 15, ${pulseAlpha})`;
                    ctx.shadowBlur = 15;
                } else if (isConnectable) {
                    borderColor = '#27ae60'; // Green glow for connectable nodes
                    borderWidth = 3;
                }

                ctx.strokeStyle = borderColor;
                ctx.lineWidth = borderWidth;

                // Apply dashed border for secondary selections
                if (useDashedBorder) {
                    ctx.setLineDash([8, 4]);
                } else {
                    ctx.setLineDash([]);
                }

                ctx.strokeRect(node.x, node.y, 150, 60);
                ctx.setLineDash([]); // Reset dash pattern

                // Category indicator bar
                const colors = {
                    'composite': '#4ec9b0',
                    'decorator': '#dcdcaa',
                    'action': '#4fc1ff',
                    'condition': '#c586c0'
                };
                ctx.fillStyle = colors[node.category];
                ctx.fillRect(node.x, node.y, 5, 60);

                // Execution order badge (bottom-right corner)
                if (node.parent) {
                    const parentNode = nodes.find(n => n.id === node.parent.id);
                    if (parentNode && parentNode.children) {
                        const orderIndex = parentNode.children.findIndex(c => c.id === node.id) + 1;
                        const badgeX = node.x + 150 - 15; // Node width (150) - margin (15)
                        const badgeY = node.y + 60 - 15;  // Node height (60) - margin (15)
                        ctx.fillStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.arc(badgeX, badgeY, 11, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.font = '600 11px Segoe UI';
                        ctx.textAlign = 'center';
                        ctx.fillText(orderIndex, badgeX, badgeY + 4);
                        ctx.textAlign = 'left';
                    }
                }

                // Node name and type (center-left area)
                ctx.fillStyle = '#ffffff';
                ctx.font = '600 13px Segoe UI';
                const nameText = node.name.substring(0, 20);
                ctx.fillText(nameText, node.x + 10, node.y + 24);

                ctx.fillStyle = '#858585';
                ctx.font = '11px Segoe UI';
                const typeText = node.type.substring(0, 20);
                ctx.fillText(typeText, node.x + 10, node.y + 40);

                // Draw node type icon (bottom-left corner)
                const icon = NODE_ICONS[node.type] || NODE_ICONS['default'];
                const iconSize = 14;
                const iconX = node.x + 10;
                const iconY = node.y + 52;

                // Draw icon background circle
                ctx.fillStyle = 'rgba(79, 193, 255, 0.15)';
                ctx.beginPath();
                ctx.arc(iconX, iconY, iconSize/2 + 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw icon
                ctx.fillStyle = '#4fc1ff';
                ctx.font = `bold ${iconSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(icon, iconX, iconY);

                // Reset text alignment
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';

                // Child count / collapse badge
                if (node.children.length > 0) {
                    ctx.fillStyle = node.collapsed ? '#e67e22' : '#858585';
                    ctx.beginPath();
                    ctx.arc(node.x + 140, node.y + 10, 11, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = '600 10px Segoe UI';
                    ctx.textAlign = 'center';
                    const symbol = node.collapsed ? '+' : node.children.length;
                    ctx.fillText(symbol, node.x + 140, node.y + 14);
                    ctx.textAlign = 'left';
                }
            });

            ctx.restore();

            // Update minimap
            renderMinimap();

            // Update counters
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('connectionCount').textContent = connectionCount;
            document.getElementById('selectedCount').textContent = selectedNodes.size;
        }

        // Track hovered node for tooltips
        let hoveredNode = null;
        let tooltipTimeout = null;

        function showNodeTooltip(node, mouseX, mouseY) {
            // Create tooltip element if it doesn't exist
            let tooltip = document.getElementById('nodeTooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'nodeTooltip';
                tooltip.style.cssText = `
                    position: fixed;
                    background: rgba(30, 30, 30, 0.95);
                    border: 1px solid #4fc1ff;
                    border-radius: 6px;
                    padding: 12px;
                    color: #d4d4d4;
                    font-size: 13px;
                    max-width: 300px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                    z-index: 10000;
                    pointer-events: none;
                `;
                document.body.appendChild(tooltip);
            }

            const description = NODE_DESCRIPTIONS[node.type] || NODE_DESCRIPTIONS['default'];
            const icon = NODE_ICONS[node.type] || NODE_ICONS['default'];

            let configInfo = '';
            if (Object.keys(node.config).length > 0) {
                configInfo = '<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #3e3e42; font-size: 11px; color: #858585;">';
                for (const [key, value] of Object.entries(node.config)) {
                    configInfo += `<div><strong>${key}:</strong> ${JSON.stringify(value)}</div>`;
                }
                configInfo += '</div>';
            }

            tooltip.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                    <span style="font-size: 20px;">${icon}</span>
                    <strong style="color: #4fc1ff;">${node.type}</strong>
                </div>
                <div style="color: #d4d4d4; line-height: 1.5;">
                    ${description}
                </div>
                ${configInfo}
            `;

            tooltip.style.display = 'block';
            tooltip.style.left = (mouseX + 15) + 'px';
            tooltip.style.top = (mouseY + 15) + 'px';
        }

        function hideNodeTooltip() {
            const tooltip = document.getElementById('nodeTooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        function renderMinimap() {
            if (!minimap || !minimapCtx) return;
            if (nodes.length === 0) {
                minimapCtx.clearRect(0, 0, minimap.width, minimap.height);
                return;
            }

            // Clear with dark background
            minimapCtx.fillStyle = '#1e1e1e';
            minimapCtx.fillRect(0, 0, minimap.width, minimap.height);

            // Find bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + 150);
                maxY = Math.max(maxY, node.y + 60);
            });

            const treeWidth = maxX - minX + 400;
            const treeHeight = maxY - minY + 400;
            const scaleX = minimap.width / treeWidth;
            const scaleY = minimap.height / treeHeight;
            const scale = Math.min(scaleX, scaleY) * 0.9; // 0.9 for padding

            const offsetX = (minimap.width - (treeWidth * scale)) / 2;
            const offsetY = (minimap.height - (treeHeight * scale)) / 2;

            // Draw connections first
            minimapCtx.strokeStyle = '#3e3e42';
            minimapCtx.lineWidth = 1;
            nodes.forEach(node => {
                if (node.parent) {
                    const parentNode = nodes.find(n => n.id === node.parent.id);
                    if (parentNode) {
                        minimapCtx.beginPath();
                        const x1 = ((parentNode.x - minX + 200) * scale) + offsetX;
                        const y1 = ((parentNode.y - minY + 200) * scale) + offsetY;
                        const x2 = ((node.x - minX + 200) * scale) + offsetX;
                        const y2 = ((node.y - minY + 200) * scale) + offsetY;
                        minimapCtx.moveTo(x1, y1);
                        minimapCtx.lineTo(x2, y2);
                        minimapCtx.stroke();
                    }
                }
            });

            // Draw nodes with category colors
            nodes.forEach(node => {
                const x = ((node.x - minX + 200) * scale) + offsetX;
                const y = ((node.y - minY + 200) * scale) + offsetY;
                const nodeWidth = 8;
                const nodeHeight = 6;

                // Color by category
                let color = '#4fc1ff';
                if (node.category === 'composite') color = '#ce9178';
                else if (node.category === 'decorator') color = '#dcdcaa';
                else if (node.category === 'action') color = '#4fc1ff';
                else if (node.category === 'condition') color = '#c586c0';

                // Highlight if simulating (check if simulationState exists)
                if (typeof simulationState !== 'undefined' && simulationState.nodeStates) {
                    const simState = simulationState.nodeStates.get(node.id);
                    if (simState && simState.status !== 'IDLE') {
                        const statusColors = {
                            'SUCCESS': '#4caf50',
                            'FAILURE': '#f44336',
                            'RUNNING': '#ff9800'
                        };
                        color = statusColors[simState.status] || color;
                    }
                }

                // Highlight if selected
                if (selectedNodes.has(node)) {
                    minimapCtx.strokeStyle = '#fff';
                    minimapCtx.lineWidth = 2;
                    minimapCtx.strokeRect(x - nodeWidth/2 - 1, y - nodeHeight/2 - 1, nodeWidth + 2, nodeHeight + 2);
                }

                minimapCtx.fillStyle = color;
                minimapCtx.fillRect(x - nodeWidth/2, y - nodeHeight/2, nodeWidth, nodeHeight);
            });

            // Draw viewport indicator
            const viewportWidth = (canvas.width / viewportScale) * scale;
            const viewportHeight = (canvas.height / viewportScale) * scale;
            const viewportX_mini = ((-viewportX / viewportScale - minX + 200) * scale) + offsetX;
            const viewportY_mini = ((-viewportY / viewportScale - minY + 200) * scale) + offsetY;

            minimapCtx.strokeStyle = '#4fc1ff';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(viewportX_mini, viewportY_mini, viewportWidth, viewportHeight);
        }

        // Layout - Hierarchical Tree Layout (Reingold-Tilford Algorithm)
        function autoLayout() {
            if (nodes.length === 0) {
                updateStatus('No nodes to layout');
                return;
            }

            const roots = nodes.filter(n => !n.parent);
            if (roots.length === 0) {
                updateStatus('‚ö† No root node found - cannot auto-layout');
                return;
            }

            const root = roots[0];

            // Configuration
            const config = {
                nodeWidth: 180,      // Approximate node width
                nodeHeight: 80,      // Approximate node height
                horizontalSpacing: 150,  // Space between sibling nodes (increased for complex trees)
                verticalSpacing: 120,   // Space between levels
                startX: 500,         // Starting X position
                startY: 100          // Starting Y position
            };

            // Phase 1: Calculate relative positions (post-order traversal)
            calculateSubtreePositions(root, config);

            // Phase 2: Convert to absolute coordinates
            // Start with root at the configured position + its offset
            const rootX = config.startX + root._layout.offset;
            applyAbsolutePositions(root, rootX, config.startY, config);

            saveHistory();
            render();

            // Auto-fit after layout
            setTimeout(() => {
                zoomFit();
            }, 50);

            updateStatus('‚úì Layout applied');
        }

        function calculateSubtreePositions(node, config) {
            // Post-order: process children first
            if (node.children.length > 0) {
                node.children.forEach(childRef => {
                    const child = nodes.find(n => n.id === childRef.id);
                    if (child) calculateSubtreePositions(child, config);
                });
            }

            // Calculate this node's position relative to its children
            if (node.children.length === 0) {
                // Leaf node: width is just the node width
                node._layout = {
                    width: config.nodeWidth,
                    offset: 0,  // Node is at center of its own subtree
                    subtreeLeft: 0  // Left edge of subtree (for positioning among siblings)
                };
            } else if (node.children.length === 1) {
                // Single child: center over child
                const childNode = nodes.find(n => n.id === node.children[0].id);
                if (childNode && childNode._layout) {
                    node._layout = {
                        width: Math.max(childNode._layout.width, config.nodeWidth),
                        offset: childNode._layout.offset,  // Align with child
                        subtreeLeft: 0
                    };
                }
            } else {
                // Multiple children: space them out and center parent
                let currentX = 0;
                const childNodes = node.children.map(ref => nodes.find(n => n.id === ref.id)).filter(n => n && n._layout);

                childNodes.forEach((childNode, i) => {
                    if (i === 0) {
                        // First child's subtree starts at 0
                        childNode._layout.subtreeLeft = 0;
                        currentX = childNode._layout.width / 2;
                    } else {
                        // Position next child's subtree after previous one with spacing
                        const subtreeLeft = currentX + config.horizontalSpacing + childNode._layout.width / 2;
                        childNode._layout.subtreeLeft = subtreeLeft;
                        currentX = subtreeLeft + childNode._layout.width / 2;
                    }
                });

                // Calculate total width and center parent
                if (childNodes.length > 0) {
                    const leftmost = childNodes[0];
                    const rightmost = childNodes[childNodes.length - 1];
                    const leftEdge = leftmost._layout.subtreeLeft - leftmost._layout.width / 2;
                    const rightEdge = rightmost._layout.subtreeLeft + rightmost._layout.width / 2;
                    const subtreeWidth = rightEdge - leftEdge;
                    const center = (leftEdge + rightEdge) / 2;

                    node._layout = {
                        width: subtreeWidth,
                        offset: center,  // Parent positioned at center of its subtree
                        subtreeLeft: 0
                    };
                }
            }
        }

        function applyAbsolutePositions(node, x, y, config) {
            // Set this node's absolute position
            node.x = x;
            node.y = y;

            // Process children if any
            if (node.children.length > 0) {
                const nextY = y + config.nodeHeight + config.verticalSpacing;

                // Calculate the absolute position of this subtree's left edge
                const subtreeOrigin = x - node._layout.offset;

                node.children.forEach(childRef => {
                    const child = nodes.find(n => n.id === childRef.id);
                    if (child && child._layout) {
                        // Child's position = subtree origin + child's subtree position + child's internal offset
                        const childSubtreeX = subtreeOrigin + child._layout.subtreeLeft;
                        const childX = childSubtreeX + child._layout.offset;
                        applyAbsolutePositions(child, childX, nextY, config);
                    }
                });
            }

            // Clean up temporary layout data
            delete node._layout;
        }

        // Zoom & View
        function zoomIn() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const worldX = (centerX - viewportX) / viewportScale;
            const worldY = (centerY - viewportY) / viewportScale;

            viewportScale = Math.min(5.0, viewportScale * 1.3);

            viewportX = centerX - worldX * viewportScale;
            viewportY = centerY - worldY * viewportScale;

            updateZoomDisplay();
            render();
        }

        function zoomOut() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const worldX = (centerX - viewportX) / viewportScale;
            const worldY = (centerY - viewportY) / viewportScale;

            viewportScale = Math.max(0.1, viewportScale * 0.7);

            viewportX = centerX - worldX * viewportScale;
            viewportY = centerY - worldY * viewportScale;

            updateZoomDisplay();
            render();
        }

        function centerViewOnNode(node) {
            // Smoothly center the viewport on a specific node
            const nodeCenterX = node.x + 75; // Node width / 2
            const nodeCenterY = node.y + 30; // Node height / 2

            viewportX = (canvas.width / 2) - (nodeCenterX * viewportScale);
            viewportY = (canvas.height / 2) - (nodeCenterY * viewportScale);

            render();
        }

        function zoomFit() {
            if (nodes.length === 0) {
                updateStatus('No nodes to fit');
                return;
            }

            // Find bounding box of all nodes
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + 150); // Node width
                maxY = Math.max(maxY, node.y + 60);  // Node height
            });

            // Tree dimensions
            const treeWidth = maxX - minX;
            const treeHeight = maxY - minY;

            // Safety check
            if (treeWidth === 0 || treeHeight === 0) {
                viewportScale = 1.0;
                viewportX = (canvas.width / 2) - (minX + 75) * viewportScale;
                viewportY = (canvas.height / 2) - (minY + 30) * viewportScale;
                updateZoomDisplay();
                render();
                return;
            }

            // Add padding
            const padding = 100; // Increased padding for better visibility
            const availableWidth = canvas.width - (padding * 2);
            const availableHeight = canvas.height - (padding * 2);

            // Calculate scale to fit (allow zooming in for small trees)
            const scaleX = availableWidth / treeWidth;
            const scaleY = availableHeight / treeHeight;
            viewportScale = Math.min(scaleX, scaleY, 2.0); // Allow up to 200% zoom

            // Clamp minimum scale to ensure visibility
            viewportScale = Math.max(viewportScale, 0.1);

            // Center the tree in the canvas
            const treeCenterX = (minX + maxX) / 2;
            const treeCenterY = (minY + maxY) / 2;

            viewportX = (canvas.width / 2) - (treeCenterX * viewportScale);
            viewportY = (canvas.height / 2) - (treeCenterY * viewportScale);

            updateZoomDisplay();
            render();
            updateStatus(`‚úì Fit to view (${Math.round(viewportScale * 100)}%)`);
        }

        function toggleGrid() {
            showGrid = !showGrid;
            document.getElementById('gridBtn').style.background = showGrid ? '#0e639c' : 'transparent';
            render();
            updateStatus(showGrid ? 'Grid enabled' : 'Grid disabled');
        }

        function toggleMinimap() {
            const panel = document.getElementById('minimapPanel');
            if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';
                updateStatus(isVisible ? 'Minimap hidden' : 'Minimap shown');
                if (!isVisible) {
                    render(); // Refresh minimap when shown
                }
            }
        }

        // Make panels draggable
        function makePanelDraggable(panel) {
            const header = panel.querySelector('.panel-header');
            if (!header) return;

            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;

            header.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on button
                if (e.target.tagName === 'BUTTON') return;

                isDragging = true;
                const rect = panel.getBoundingClientRect();

                initialX = e.clientX - rect.left;
                initialY = e.clientY - rect.top;

                panel.style.zIndex = 1000;
                header.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                e.preventDefault();

                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;

                // Keep panel within viewport bounds
                const maxX = window.innerWidth - panel.offsetWidth;
                const maxY = window.innerHeight - panel.offsetHeight;

                currentX = Math.max(0, Math.min(currentX, maxX));
                currentY = Math.max(0, Math.min(currentY, maxY));

                panel.style.left = currentX + 'px';
                panel.style.top = currentY + 'px';
                panel.style.right = 'auto';
                panel.style.bottom = 'auto';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    header.style.cursor = 'move';
                    panel.style.zIndex = 100;
                }
            });
        }

        // Initialize draggable panels
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.draggable-panel').forEach(makePanelDraggable);

            // Initialize simulation mode toggle to Auto (checked)
            const toggle = document.getElementById('simModeToggle');
            if (toggle) {
                toggle.checked = true;
                toggleSimulationMode(); // Apply initial state
            }
        });

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(viewportScale * 100) + '%';
        }

        // History (Undo/Redo)
        function saveHistory() {
            // Dehydrate nodes to remove circular references before stringifying
            const dehydratedNodes = nodes.map(node => ({
                ...node,
                parent: node.parent && node.parent.id ? { id: node.parent.id } : null,
                children: node.children.map(child =>
                    child && child.id ? { id: child.id } : child
                )
            }));

            const state = {
                nodes: JSON.parse(JSON.stringify(dehydratedNodes)),
                selectedNodeId: selectedNode ? selectedNode.id : null,
                nextNodeId: nextNodeId
            };

            // Remove future history if we're not at the end
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            history.push(state);
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }

            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreHistoryState(history[historyIndex]);
                updateStatus('Undo');
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreHistoryState(history[historyIndex]);
                updateStatus('Redo');
            }
        }

        function restoreHistoryState(state) {
            nodes = JSON.parse(JSON.stringify(state.nodes));
            nextNodeId = state.nextNodeId;

            // Restore object references
            nodes.forEach(node => {
                if (node.parent) {
                    const parentId = node.parent.id;
                    node.parent = nodes.find(n => n.id === parentId);
                } else {
                    node.parent = null;
                }

                node.children = node.children.map(childData => {
                    return nodes.find(n => n.id === childData.id);
                });
            });

            selectedNode = state.selectedNodeId ? nodes.find(n => n.id === state.selectedNodeId) : null;
            showProperties(selectedNode);
            updateHistoryButtons();
            render();
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }

        // Tree Operations
        function newTree() {
            if (nodes.length > 0 && !confirm('Create new tree? Current tree will be lost if not saved.')) {
                return;
            }

            nodes = [];
            selectedNode = null;
            nextNodeId = 1;
            connectMode = false;
            connectFromNode = null;
            currentTreeName = "Untitled Tree";
            currentTreeId = null;
            history = [];
            historyIndex = -1;

            // Reset simulation and clear blackboard
            pauseSimulation();
            initializeSimulation();
            updateBlackboardDisplay();

            hideConnectHint();
            showProperties(null);
            updateHistoryButtons();
            updateTreeNameDisplay();
            render();
            updateStatus('New tree created');
        }

        function nodeToJSON(node) {
            const result = {
                node_type: node.type,
                name: node.name,
                config: node.config
            };

            if (node.children.length > 0) {
                result.children = node.children.map(child => nodeToJSON(child));
            }

            return result;
        }

        function exportTree() {
            const roots = nodes.filter(n => !n.parent);
            if (roots.length === 0) {
                alert('No root node. Add a composite or decorator node first.');
                return;
            }

            const tree = {
                "$schema": "1.0.0",
                "tree_id": currentTreeId || crypto.randomUUID(),
                "metadata": {
                    "name": currentTreeName,
                    "version": "1.0.0",
                    "description": "Created with TalkingTrees Editor",
                    "tags": ["editor"],
                    "status": "draft"
                },
                "root": nodeToJSON(roots[0])
            };

            const json = JSON.stringify(tree, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentTreeName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
            a.click();
            updateStatus('Tree exported as JSON');
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const treeData = JSON.parse(e.target.result);
                    importTreeFromJSON(treeData);
                    updateStatus(`‚úì Imported tree from ${file.name}`);
                    // Reset file input so the same file can be imported again
                    event.target.value = '';
                } catch (error) {
                    alert(`Failed to import tree: ${error.message}`);
                    updateStatus(`‚ùå Import failed: ${error.message}`);
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }

        function importTreeFromJSON(treeData) {
            // Clear current tree
            nodes = [];
            connections = [];
            selectedNode = null;
            nodeCounter = 1;

            // Reset simulation and clear blackboard
            pauseSimulation();
            initializeSimulation();
            updateBlackboardDisplay();

            // Set tree metadata
            if (treeData.metadata) {
                currentTreeName = treeData.metadata.name || 'Imported Tree';
                currentTreeId = treeData.tree_id || null;
            }

            // Convert JSON tree to internal node format
            if (treeData.root) {
                const rootNode = jsonToNode(treeData.root, null, 200, 100);
                nodes.push(rootNode);
                layoutSubtree(rootNode);
            }

            saveHistory();
            render();

            // Auto-layout after import
            autoLayout();
        }

        function jsonToNode(jsonNode, parentId, x, y) {
            const nodeType = jsonNode.node_type;
            const nodeDef = NODE_DEFS[nodeType];

            if (!nodeDef) {
                console.warn(`Unknown node type: ${nodeType}`);
                return null;
            }

            const node = {
                id: nodeCounter++,
                type: nodeType,
                name: jsonNode.name || nodeType,
                category: nodeDef.category,
                config: { ...jsonNode.config },
                children: [],
                parent: parentId ? { id: parentId } : null,
                x: x,
                y: y
            };

            // Recursively create children
            if (jsonNode.children && jsonNode.children.length > 0) {
                const childSpacing = 200;
                const startX = x - (jsonNode.children.length - 1) * childSpacing / 2;

                jsonNode.children.forEach((childJSON, index) => {
                    const childX = startX + index * childSpacing;
                    const childY = y + 150;
                    const childNode = jsonToNode(childJSON, node.id, childX, childY);
                    if (childNode) {
                        node.children.push({ id: childNode.id });
                        nodes.push(childNode);
                        connections.push({
                            from: node.id,
                            to: childNode.id
                        });
                    }
                });
            }

            return node;
        }

        function layoutSubtree(node) {
            if (!node || node.children.length === 0) return;

            const childSpacing = 200;
            const startX = node.x - (node.children.length - 1) * childSpacing / 2;

            node.children.forEach((childRef, index) => {
                const childNode = nodes.find(n => n.id === childRef.id);
                if (childNode) {
                    childNode.x = startX + index * childSpacing;
                    childNode.y = node.y + 150;
                    layoutSubtree(childNode);
                }
            });
        }

        async function saveToAPI() {
            const roots = nodes.filter(n => !n.parent);
            if (roots.length === 0) {
                alert('No root node');
                return;
            }

            const tree = {
                "$schema": "1.0.0",
                "tree_id": currentTreeId || crypto.randomUUID(),
                "metadata": {
                    "name": currentTreeName,
                    "version": "1.0.0",
                    "description": "Created with TalkingTrees Editor",
                    "tags": ["editor"],
                    "status": "draft"
                },
                "root": nodeToJSON(roots[0])
            };

            try {
                const response = await fetch(`${API_BASE}/trees/`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(tree)
                });

                if (response.ok) {
                    const result = await response.json();
                    currentTreeId = result.tree_id;
                    updateStatus(`Tree saved to API! ID: ${result.tree_id}`);
                    alert('Tree saved successfully to TalkingTrees API!');
                } else {
                    const error = await response.text();
                    alert('Failed to save tree: ' + error);
                }
            } catch (error) {
                alert('Error connecting to API: ' + error.message);
            }
        }

        // Copy Python Code
        let selectedPythonOption = null;
        let generatedPythonCode = '';

        function openCopyPythonModal() {
            const roots = nodes.filter(n => !n.parent);
            if (roots.length === 0) {
                alert('No root node to export');
                return;
            }

            // Reset state
            selectedPythonOption = null;
            document.getElementById('pythonCodeDisplay').style.display = 'none';
            document.querySelectorAll('#copyPythonModal [onclick^="selectPythonOption"]').forEach(el => {
                el.classList.remove('selected');
                el.style.borderColor = '#3e3e42';
            });

            // Open modal
            document.getElementById('copyPythonModal').classList.add('active');
        }

        async function selectPythonOption(option, element) {
            // Visual feedback
            document.querySelectorAll('#copyPythonModal [onclick^="selectPythonOption"]').forEach(el => {
                el.classList.remove('selected');
                el.style.borderColor = '#3e3e42';
            });
            element.classList.add('selected');
            element.style.borderColor = '#4fc1ff';

            selectedPythonOption = option;

            const roots = nodes.filter(n => !n.parent);
            const tree = {
                "$schema": "1.0.0",
                "tree_id": currentTreeId || crypto.randomUUID(),
                "metadata": {
                    "name": currentTreeName,
                    "version": "1.0.0",
                    "description": "Created with TalkingTrees Editor",
                    "tags": ["editor"],
                    "status": "draft"
                },
                "root": nodeToJSON(roots[0])
            };

            if (option === 'file') {
                // Generate code to load from file
                const filename = `${currentTreeName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;

                generatedPythonCode = `"""
${currentTreeName} - TalkingTrees Behavior Tree
Generated by TalkingTrees Tree Editor
"""

from talking_trees.sdk import TalkingTrees

# Initialize TalkingTrees SDK
pf = TalkingTrees()

# Load tree from JSON file
# (First, export the tree using the 'Export' button to save ${filename})
tree = pf.load_tree("${filename}")

# Option 1: Create and run execution
execution = pf.create_execution(tree)

# Run with optional blackboard updates
result = execution.tick(blackboard_updates={
    # Add your variables here, e.g.:
    # "battery_level": 50,
    # "target_position": [10, 20]
})

print(f"Execution result: {result.status}")
print(f"Blackboard: {result.blackboard}")

# Option 2: Use with py_trees (convert back)
from talking_trees.adapters import to_py_trees

pt_root = to_py_trees(tree)
pt_root.setup_with_descendants()
pt_root.tick_once()
print(f"py_trees result: {pt_root.status}")
`;

                document.getElementById('pythonCodeDisplay').style.display = 'block';
                document.getElementById('generatedPythonCode').textContent = generatedPythonCode;

            } else if (option === 'api') {
                // Save to API first
                updateStatus('Saving to API...');

                try {
                    const response = await fetch(`${API_BASE}/trees/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(tree)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        currentTreeId = result.tree_id;

                        // Generate code to load from API
                        generatedPythonCode = `"""
${currentTreeName} - TalkingTrees Behavior Tree
Generated by TalkingTrees Tree Editor
Saved to API with ID: ${result.tree_id}
"""

from talking_trees.sdk import TalkingTrees

# Initialize TalkingTrees SDK with API connection
pf = TalkingTrees(api_url="http://localhost:8000")

# Load tree from API
tree = pf.get_tree("${result.tree_id}")

print(f"Loaded tree: {tree.metadata.name} v{tree.metadata.version}")

# Create execution
execution = pf.create_execution(tree)

# Run with optional blackboard updates
result = execution.tick(blackboard_updates={
    # Add your variables here, e.g.:
    # "battery_level": 50,
    # "target_position": [10, 20]
})

print(f"Execution result: {result.status}")
print(f"Blackboard: {result.blackboard}")

# Option: Use with py_trees (convert back)
from talking_trees.adapters import to_py_trees

pt_root = to_py_trees(tree)
pt_root.setup_with_descendants()
pt_root.tick_once()
print(f"py_trees result: {pt_root.status}")
`;

                        document.getElementById('pythonCodeDisplay').style.display = 'block';
                        document.getElementById('generatedPythonCode').textContent = generatedPythonCode;
                        updateStatus(`Tree saved! ID: ${result.tree_id}`);
                    } else {
                        const error = await response.text();
                        alert('Failed to save tree to API: ' + error);
                        element.classList.remove('selected');
                        element.style.borderColor = '#3e3e42';
                    }
                } catch (error) {
                    alert('Error connecting to API: ' + error.message + '\n\nMake sure the API server is running (python run_server.py)');
                    element.classList.remove('selected');
                    element.style.borderColor = '#3e3e42';
                }
            }
        }

        function copyGeneratedPythonCode(event) {
            if (!generatedPythonCode) return;

            navigator.clipboard.writeText(generatedPythonCode).then(() => {
                updateStatus('Python code copied to clipboard!');

                // Visual feedback
                const btn = event.target;
                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úì Copied!';
                btn.style.background = '#1a9870';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '#16825d';
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard: ' + err);
            });
        }

        // Library Management
        function saveToLibrary() {
            const roots = nodes.filter(n => !n.parent);
            if (roots.length === 0) {
                alert('No root node to save');
                return;
            }

            document.getElementById('saveTreeName').value = currentTreeName;
            document.getElementById('saveTreeDesc').value = '';
            document.getElementById('saveModal').classList.add('active');
        }

        async function confirmSaveToLibrary() {
            const name = document.getElementById('saveTreeName').value.trim();
            const desc = document.getElementById('saveTreeDesc').value.trim();

            if (!name) {
                alert('Please enter a tree name');
                return;
            }

            const roots = nodes.filter(n => !n.parent);
            const library = await getLibrary();

            const entry = {
                id: crypto.randomUUID(),
                name: name,
                description: desc,
                created: new Date().toISOString(),
                nodes: JSON.parse(JSON.stringify(nodes)),
                rootNodeId: roots[0].id
            };

            library.push(entry);
            saveLibrary(library);

            currentTreeName = name;
            updateTreeNameDisplay();
            closeModal('saveModal');
            updateStatus(`Tree saved to library: ${name}`);
            loadLibrary();
        }

        async function loadLibrary() {
            const library = await getLibrary();
            const content = document.getElementById('libraryContent');

            if (library.length === 0) {
                content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center;">No saved trees yet. Save your current tree to the library!</div>';
                return;
            }

            let html = '';
            library.forEach(entry => {
                const date = new Date(entry.created).toLocaleDateString();
                html += `
                    <div class="library-item" onclick="loadFromLibrary('${entry.id}')">
                        <div class="library-item-title">${entry.name}</div>
                        <div class="library-item-desc">${entry.description || 'No description'}</div>
                        <div class="library-item-meta">
                            <span>üìÖ ${date}</span>
                            <span>üîó ${entry.nodes.length} nodes</span>
                        </div>
                    </div>
                `;
            });

            content.innerHTML = html;
        }

        async function loadFromLibrary(id) {
            if (nodes.length > 0 && !confirm('Load tree? Current tree will be lost if not saved.')) {
                return;
            }

            const library = await getLibrary();
            const entry = library.find(e => e.id === id);

            if (!entry) return;

            nodes = JSON.parse(JSON.stringify(entry.nodes));

            // Restore object references
            nodes.forEach(node => {
                if (node.parent) {
                    const parentId = node.parent.id;
                    node.parent = nodes.find(n => n.id === parentId);
                } else {
                    node.parent = null;
                }

                node.children = node.children.map(childData => {
                    return nodes.find(n => n.id === childData.id);
                });
            });

            currentTreeName = entry.name;
            selectedNode = null;
            history = [];
            historyIndex = -1;

            // Reset simulation and clear blackboard
            resetSimulation();

            hideQuickStartHint();
            updateTreeNameDisplay();
            updateHistoryButtons();
            showProperties(null);
            autoLayout();
            updateStatus(`‚úì Loaded: ${entry.name}`);
        }

        async function loadFromLibraryAndClose(id) {
            await loadFromLibrary(id);
            closeModal('loadModal');
        }

        async function openLoadModal() {
            document.getElementById('loadModal').classList.add('active');
            // Default to local mode
            document.querySelector('input[name="loadMode"][value="local"]').checked = true;
            await switchLoadMode('local');
        }

        async function switchLoadMode(mode) {
            const content = document.getElementById('loadModalContent');
            content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center;">Loading...</div>';

            if (mode === 'local') {
                await loadLocalTrees();
            } else {
                await loadRemoteTrees();
            }
        }

        async function loadLocalTrees() {
            const content = document.getElementById('loadModalContent');

            try {
                // Fetch manifest from examples/trees/
                const response = await fetch('../examples/trees/manifest.json');
                if (!response.ok) throw new Error('Cannot load manifest');

                const manifest = await response.json();

                if (manifest.length === 0) {
                    content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center;">No example trees found</div>';
                    return;
                }

                let html = '';
                manifest.forEach(entry => {
                    const tags = entry.tags ? entry.tags.map(t => `<span style="background: #3e3e42; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px;">${t}</span>`).join('') : '';
                    html += `
                        <div class="library-item" onclick="loadTreeFromLocalFile('${entry.file}', '${entry.name}')">
                            <div class="library-item-title">${entry.name}</div>
                            <div class="library-item-desc">${entry.description || 'No description'}</div>
                            <div class="library-item-meta">
                                ${tags}
                            </div>
                        </div>
                    `;
                });

                content.innerHTML = html;
            } catch (error) {
                content.innerHTML = `<div style="color: #e06c75; padding: 20px; text-align: center;">Error loading examples: ${error.message}</div>`;
            }
        }

        async function loadRemoteTrees() {
            const content = document.getElementById('loadModalContent');

            try {
                // Fetch from API
                const response = await fetch(`${API_BASE}/trees/`);
                if (!response.ok) throw new Error('API not available');

                const catalog = await response.json();

                if (catalog.length === 0) {
                    content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center;">No trees in remote library</div>';
                    return;
                }

                let html = '';
                catalog.forEach(entry => {
                    const tags = entry.tags ? entry.tags.map(t => `<span style="background: #3e3e42; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px;">${t}</span>`).join('') : '';
                    html += `
                        <div class="library-item" onclick="loadTreeFromRemoteAPI('${entry.tree_id}', '${entry.tree_name}')">
                            <div class="library-item-title">${entry.display_name}</div>
                            <div class="library-item-desc">${entry.description || 'No description'}</div>
                            <div class="library-item-meta">
                                <span>v${entry.latest_version}</span>
                                ${tags}
                            </div>
                        </div>
                    `;
                });

                content.innerHTML = html;
            } catch (error) {
                content.innerHTML = `<div style="color: #e06c75; padding: 20px; text-align: center;">Error connecting to API: ${error.message}<br><br>Make sure the API server is running at ${API_BASE}</div>`;
            }
        }

        async function loadTreeFromLocalFile(filename, treeName) {
            if (nodes.length > 0 && !confirm(`Load "${treeName}"? Current tree will be lost if not saved.`)) {
                return;
            }

            try {
                const response = await fetch(`../examples/trees/${filename}`);
                if (!response.ok) throw new Error('Cannot load tree file');

                const treeData = await response.json();
                await importTreeFromJSON(treeData);
                closeModal('loadModal');
                updateStatus(`Loaded: ${treeName}`);
            } catch (error) {
                alert(`Error loading tree: ${error.message}`);
            }
        }

        async function loadTreeFromRemoteAPI(treeId, treeName) {
            if (nodes.length > 0 && !confirm(`Load "${treeName}"? Current tree will be lost if not saved.`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/trees/${treeId}`);
                if (!response.ok) throw new Error('Cannot load tree from API');

                const treeData = await response.json();
                await importTreeFromJSON(treeData);
                closeModal('loadModal');
                updateStatus(`Loaded from API: ${treeName}`);
            } catch (error) {
                alert(`Error loading tree from API: ${error.message}`);
            }
        }

        async function loadFromLibraryAndClose(id) {
            await loadFromLibrary(id);
            closeModal('loadModal');
        }

        
        // Load trees from REST API
        async function loadTreesFromAPI() {
            try {
                // Step 1: Get list of tree catalog entries
                const catalogResponse = await fetch(`${API_BASE}/trees/`);
                if (!catalogResponse.ok) throw new Error('API not available');

                const catalog = await catalogResponse.json();
                console.log(`Found ${catalog.length} trees in catalog`);

                // Step 2: Fetch full TreeDefinition for each tree
                const treePromises = catalog.map(entry =>
                    fetch(`${API_BASE}/trees/${entry.tree_id}`).then(r => r.json())
                );
                const apiTrees = await Promise.all(treePromises);
                console.log(`Loaded ${apiTrees.length} full tree definitions`);

                // Step 3: Convert API format to GUI format
                const guiTrees = apiTrees.map(apiTree => {
                    const nodes = [];
                    let nextId = 1;

                    function convertNode(apiNode, parent = null) {
                        const id = nextId++;
                        const guiNode = {
                            id: id,
                            type: apiNode.node_type,
                            category: NODE_DEFS[apiNode.node_type]?.category || 'action',
                            name: apiNode.name,
                            x: 400 + (Math.random() - 0.5) * 200,
                            y: 100 + (nextId - 1) * 100,
                            config: apiNode.config || {},
                            children: [],
                            parent: parent,
                            collapsed: false
                        };

                        nodes.push(guiNode);

                        if (apiNode.children && apiNode.children.length > 0) {
                            guiNode.children = apiNode.children.map(child => {
                                const childNode = convertNode(child, { id: id });
                                return { id: childNode.id };
                            });
                        }

                        return guiNode;
                    }

                    convertNode(apiTree.root);

                    return {
                        id: apiTree.tree_id,
                        name: apiTree.metadata.name,
                        description: apiTree.metadata.description || '',
                        created: apiTree.metadata.created_at || new Date().toISOString(),
                        nodes: nodes,
                        rootNodeId: 1
                    };
                });

                return guiTrees;
            } catch (error) {
                console.log('Could not load from API:', error);
                return null;
            }
        }

async function getLibrary() {
            const data = localStorage.getItem(STORAGE_KEY_LIBRARY);
            const versionData = localStorage.getItem(STORAGE_KEY_LIBRARY + '_version');

            // Force reload if version changed or no library
            if (!data || versionData !== LIBRARY_VERSION) {
                console.log('Loading fresh library (version changed or empty)');
                
                // Try to load from API first
                const apiTrees = await loadTreesFromAPI();
                if (apiTrees && apiTrees.length > 0) {
                    console.log('Using trees from API');
                    saveLibrary(apiTrees);
                    localStorage.setItem(STORAGE_KEY_LIBRARY + '_version', LIBRARY_VERSION);
                    return apiTrees;
                }
                
                // Fall back to demo trees
                console.log('API not available, using demo trees');
                const newLibrary = createDemoLibrary();
                localStorage.setItem(STORAGE_KEY_LIBRARY + '_version', LIBRARY_VERSION);
                return newLibrary;
            }

            return JSON.parse(data);
        }

        function createDemoLibrary() {
            const demos = [
                {
                    id: crypto.randomUUID(),
                    name: "Robot Controller Demo",
                    description: "Priority-based robot automation with battery monitoring, object detection, and patrol. Ready to export and test with test_complete_flow.py!",
                    created: new Date().toISOString(),
                    nodes: createRobotControllerNodes(),
                    rootNodeId: 1
                },
                {
                    id: crypto.randomUUID(),
                    name: "Simple Patrol Behavior",
                    description: "Basic 2-node example: Check condition ‚Üí Set action. Good starting point for learning.",
                    created: new Date().toISOString(),
                    nodes: createSimplePatrolNodes(),
                    rootNodeId: 1
                }
            ];

            saveLibrary(demos);
            return demos;
        }

        function createRobotControllerNodes() {
            // DECORATOR PATTERN - CheckBlackboardCondition wraps SetVariable
            // Decorator only runs child if condition passes!
            const nodes = [
                { id: 1, type: 'Selector', category: 'composite', name: 'Robot Controller', x: 500, y: 100, config: { memory: false }, children: [], parent: null, collapsed: false },
                { id: 2, type: 'CheckBlackboardCondition', category: 'decorator', name: 'IF Battery < 20', x: 250, y: 250, config: { variable: 'battery_level', operator_str: '<', value: 20 }, children: [], parent: null, collapsed: false },
                { id: 3, type: 'SetBlackboardVariable', category: 'action', name: 'THEN Charge', x: 250, y: 400, config: { variable: 'robot_action', value: 'charge' }, children: [], parent: null, collapsed: false },
                { id: 4, type: 'CheckBlackboardCondition', category: 'decorator', name: 'IF Object < 5m', x: 500, y: 250, config: { variable: 'object_distance', operator_str: '<', value: 5.0 }, children: [], parent: null, collapsed: false },
                { id: 5, type: 'SetBlackboardVariable', category: 'action', name: 'THEN Grasp', x: 500, y: 400, config: { variable: 'robot_action', value: 'grasp' }, children: [], parent: null, collapsed: false },
                { id: 6, type: 'SetBlackboardVariable', category: 'action', name: 'ELSE Patrol', x: 750, y: 250, config: { variable: 'robot_action', value: 'patrol' }, children: [], parent: null, collapsed: false }
            ];

            // Set up parent-child relationships - Decorator pattern
            nodes[0].children = [{ id: 2 }, { id: 4 }, { id: 6 }]; // Root selector: 3 branches
            nodes[1].parent = { id: 1 }; // CheckBattery decorator
            nodes[1].children = [{ id: 3 }]; // Decorator wraps SetVariable
            nodes[2].parent = { id: 2 }; // SetVariable child of decorator
            nodes[3].parent = { id: 1 }; // CheckDistance decorator
            nodes[3].children = [{ id: 5 }]; // Decorator wraps SetVariable
            nodes[4].parent = { id: 4 }; // SetVariable child of decorator
            nodes[5].parent = { id: 1 }; // Default action

            return nodes;
        }

        function createSimplePatrolNodes() {
            const nodes = [
                { id: 1, type: 'CheckBlackboardCondition', category: 'decorator', name: 'Check Ready', x: 400, y: 100, config: { variable: 'ready', operator_str: '==', value: true }, children: [], parent: null, collapsed: false },
                { id: 2, type: 'SetBlackboardVariable', category: 'action', name: 'Start Patrol', x: 400, y: 250, config: { variable: 'action', value: 'patrol' }, children: [], parent: null, collapsed: false }
            ];

            nodes[0].children = [{ id: 2 }];
            nodes[1].parent = { id: 1 };

            return nodes;
        }

        function saveLibrary(library) {
            localStorage.setItem(STORAGE_KEY_LIBRARY, JSON.stringify(library));
        }

        function restoreLastSession() {
            const data = localStorage.getItem(STORAGE_KEY_CURRENT);
            if (data) {
                try {
                    const state = JSON.parse(data);
                    // Could restore last working tree here
                } catch (e) {
                    console.error('Failed to restore session:', e);
                }
            }
        }

        // Validation
        function validateTree() {
            const content = document.getElementById('propertiesContent');
            const errors = [];
            const warnings = [];
            const info = [];

            // Check for root
            const roots = nodes.filter(n => !n.parent);
            if (roots.length === 0) {
                errors.push('No root node found. Add a Sequence or Selector as the root.');
            } else if (roots.length > 1) {
                errors.push(`Multiple root nodes found (${roots.length}). Only one root is allowed.`);
            }

            // Check for orphaned nodes (unreachable)
            const reachable = new Set();
            function markReachable(node) {
                reachable.add(node);
                node.children.forEach(childRef => {
                    const child = nodes.find(n => n.id === childRef.id);
                    if (child) markReachable(child);
                });
            }
            if (roots.length > 0) {
                markReachable(roots[0]);
            }
            const orphaned = nodes.filter(n => !reachable.has(n));
            if (orphaned.length > 0) {
                warnings.push(`${orphaned.length} unreachable node(s): ${orphaned.map(n => n.name).slice(0, 3).join(', ')}${orphaned.length > 3 ? '...' : ''}`);
            }

            // Blackboard variable tracking
            const bbWritten = new Set();
            const bbRead = new Map(); // Map<variable, node[]>
            const bbNodes = [];

            nodes.forEach(node => {
                // Track blackboard writes
                if (node.type === 'SetBlackboardVariable' && node.config.variable) {
                    bbWritten.add(node.config.variable);
                    bbNodes.push(node);
                }

                // Track blackboard reads
                const readVars = [];
                if (['CheckBlackboardVariableValue', 'CheckBlackboardVariableExists',
                     'WaitForBlackboardVariable', 'WaitForBlackboardVariableValue',
                     'UnsetBlackboardVariable', 'BlackboardToStatus', 'EternalGuard', 'Condition'].includes(node.type)) {
                    if (node.config.variable) readVars.push(node.config.variable);
                }
                if (node.type === 'CheckBlackboardVariableValues' && node.config.checks) {
                    node.config.checks.forEach(check => readVars.push(check.variable));
                }

                readVars.forEach(varName => {
                    if (!bbRead.has(varName)) bbRead.set(varName, []);
                    bbRead.get(varName).push(node);
                });
            });

            // Check for undefined variables being read
            bbRead.forEach((readingNodes, varName) => {
                if (!bbWritten.has(varName)) {
                    warnings.push(`Variable "${varName}" is read by ${readingNodes[0].name} but never written. Initialize it first.`);
                }
            });

            // Check for unused variables
            bbWritten.forEach(varName => {
                if (!bbRead.has(varName)) {
                    info.push(`Variable "${varName}" is written but never read. Consider removing it.`);
                }
            });

            // Check decorator children
            nodes.forEach(node => {
                const def = NODE_DEFS[node.type];
                if (!def) return;

                if (def.maxChildren === 1 && node.children.length === 0) {
                    warnings.push(`"${node.name}" (${node.type}) requires a child node to function.`);
                }
                if (def.maxChildren === 1 && node.children.length > 1) {
                    errors.push(`"${node.name}" (${node.type}) can only have 1 child, has ${node.children.length}.`);
                }
                if (def.maxChildren === 0 && node.children.length > 0) {
                    errors.push(`"${node.name}" (${node.type}) cannot have children.`);
                }
            });

            // Check for missing or invalid config values
            nodes.forEach(node => {
                const def = NODE_DEFS[node.type];
                if (!def) return;

                // Check Retry decorator
                if (node.type === 'Retry' && (!node.config.num_failures || node.config.num_failures < 1)) {
                    warnings.push(`"${node.name}" should have num_failures >= 1.`);
                }

                // Check Timeout decorator
                if (node.type === 'Timeout' && (!node.config.duration || node.config.duration <= 0)) {
                    warnings.push(`"${node.name}" should have duration > 0.`);
                }

                // Check Wait action
                if (node.type === 'Wait' && (!node.config.duration || node.config.duration <= 0)) {
                    warnings.push(`"${node.name}" should have duration > 0.`);
                }

                // Check blackboard operations have variable names
                if (['SetBlackboardVariable', 'CheckBlackboardVariableValue', 'CheckBlackboardVariableExists'].includes(node.type)) {
                    if (!node.config.variable || node.config.variable.trim() === '') {
                        errors.push(`"${node.name}" requires a variable name.`);
                    }
                }
            });

            // Check for potentially infinite sequences
            nodes.forEach(node => {
                if (node.type === 'Sequence') {
                    const allSuccess = node.children.every(childRef => {
                        const child = nodes.find(n => n.id === childRef.id);
                        return child && child.type === 'Success';
                    });
                    if (allSuccess && node.children.length > 0) {
                        info.push(`"${node.name}" contains only Success nodes - will always succeed immediately.`);
                    }
                }
            });

            // Display results
            let html = '<div class="section-title">Validation Results</div>';

            if (errors.length === 0 && warnings.length === 0 && info.length === 0) {
                html += '<div class="validation-message success"><strong>‚úì Excellent!</strong><br>Tree structure is valid, well-formed, and ready for execution.</div>';
            }

            if (errors.length > 0) {
                html += '<div class="validation-message error"><strong>‚õî Errors (Must Fix):</strong><ul style="margin: 10px 0 0 20px;">';
                errors.forEach(err => html += `<li>${err}</li>`);
                html += '</ul></div>';
            }

            if (warnings.length > 0) {
                html += '<div class="validation-message warning"><strong>‚ö† Warnings (Should Fix):</strong><ul style="margin: 10px 0 0 20px;">';
                warnings.forEach(warn => html += `<li>${warn}</li>`);
                html += '</ul></div>';
            }

            if (info.length > 0) {
                html += '<div class="validation-message info"><strong>üí° Suggestions:</strong><ul style="margin: 10px 0 0 20px;">';
                info.forEach(i => html += `<li>${i}</li>`);
                html += '</ul></div>';
            }

            if (bbNodes.length > 0) {
                html += `<div class="validation-message info"><strong>üìä Blackboard Variables:</strong><br>`;
                html += `<span style="font-size: 12px; color: #858585;">${Array.from(bbWritten).join(', ') || 'None'}</span></div>`;
            }

            content.innerHTML = html;
            updateStatus(errors.length > 0 ? 'Validation failed' : (warnings.length > 0 ? 'Validation passed with warnings' : 'Validation passed'));

            // Return validation result
            return {
                passed: errors.length === 0,
                errors: errors,
                warnings: warnings,
                info: info
            };
        }

        // Connect Mode
        function toggleConnectMode() {
            connectMode = !connectMode;
            connectFromNode = null;

            const btn = document.getElementById('connectBtn');
            if (connectMode) {
                btn.style.background = '#f39c12';
                btn.style.color = 'white';
                canvas.style.cursor = 'crosshair';
                showConnectHint();
                updateStatus('Connect Mode: Click parent node, then child node');
            } else {
                btn.style.background = 'transparent';
                btn.style.color = '#d4d4d4';
                canvas.style.cursor = 'default';
                hideConnectHint();
                updateStatus('Connect Mode off');
            }
            render();
        }

        // Load Robot Controller Example
        function loadRobotExample() {
            if (nodes.length > 0 && !confirm('Load example? Current tree will be replaced.')) {
                return;
            }

            // Clear
            nodes = [];
            selectedNode = null;
            nextNodeId = 1;
            currentTreeName = "Robot Controller Example";

            // DECORATOR PATTERN - Check wraps action, action only runs if check passes!
            const root = createNodeDirect('Selector', 500, 100, 'Robot Controller');
            root.config.memory = false;

            // Branch 1: Check battery, if low ‚Üí charge
            const checkBattery = createNodeDirect('CheckBlackboardCondition', 250, 250, 'IF Battery < 20');
            checkBattery.config.variable = 'battery_level';
            checkBattery.config.operator_str = '<';
            checkBattery.config.value = 20;

            const setBatteryAction = createNodeDirect('SetBlackboardVariable', 250, 400, 'THEN Charge');
            setBatteryAction.config.variable = 'robot_action';
            setBatteryAction.config.value = 'charge';

            // Branch 2: Check distance, if close ‚Üí grasp
            const checkDistance = createNodeDirect('CheckBlackboardCondition', 500, 250, 'IF Object < 5m');
            checkDistance.config.variable = 'object_distance';
            checkDistance.config.operator_str = '<';
            checkDistance.config.value = 5.0;

            const setGraspAction = createNodeDirect('SetBlackboardVariable', 500, 400, 'THEN Grasp');
            setGraspAction.config.variable = 'robot_action';
            setGraspAction.config.value = 'grasp';

            // Branch 3: Default fallback
            const defaultAction = createNodeDirect('SetBlackboardVariable', 750, 250, 'ELSE Patrol');
            defaultAction.config.variable = 'robot_action';
            defaultAction.config.value = 'patrol';

            // Connect tree structure - Decorator pattern!
            root.children = [checkBattery, checkDistance, defaultAction];
            checkBattery.parent = root;
            checkDistance.parent = root;
            defaultAction.parent = root;

            // CheckBlackboard decorators each have SetVariable as child
            checkBattery.children = [setBatteryAction];
            setBatteryAction.parent = checkBattery;

            checkDistance.children = [setGraspAction];
            setGraspAction.parent = checkDistance;

            history = [];
            historyIndex = -1;
            hideQuickStartHint();
            updateTreeNameDisplay();
            updateHistoryButtons();
            render();
            updateStatus('‚úì Robot Controller loaded! Decorator pattern: Check wraps Action.');
        }

        function createNodeDirect(type, x, y, name) {
            const def = NODE_DEFS[type];
            const node = {
                id: nextNodeId++,
                type: type,
                category: def.category,
                name: name || type,
                x: x,
                y: y,
                config: JSON.parse(JSON.stringify(def.config)),
                children: [],
                parent: null,
                collapsed: false
            };
            nodes.push(node);
            return node;
        }

        // UI Helpers
        function switchTab(tab) {
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));

            if (tab === 'palette') {
                document.querySelectorAll('.sidebar-tab')[0].classList.add('active');
                document.getElementById('paletteTab').style.display = 'block';
                document.getElementById('libraryTab').style.display = 'none';
            } else {
                document.querySelectorAll('.sidebar-tab')[1].classList.add('active');
                document.getElementById('paletteTab').style.display = 'none';
                document.getElementById('libraryTab').style.display = 'block';

                // Load library when switching to it
                const mode = document.querySelector('input[name="libMode"]:checked')?.value || 'local';
                loadLibraryMode(mode);
            }
        }

        async function loadLibraryMode(mode) {
            const content = document.getElementById('libraryContent');
            content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center;">Loading...</div>';

            if (mode === 'local') {
                await loadLocalLibrary();
            } else {
                await loadRemoteLibrary();
            }
        }

        async function loadLocalLibrary() {
            const content = document.getElementById('libraryContent');

            try {
                // Try multiple paths for manifest - depends on how HTML is served
                let response;
                let manifestPath;

                // Try path from visualization/ directory first
                try {
                    response = await fetch('../examples/trees/manifest.json');
                    if (response.ok) {
                        manifestPath = '../examples/trees/';
                    }
                } catch (e) {
                    // First path failed, will try second
                }

                // If first path didn't work, try from repo root
                if (!response || !response.ok) {
                    try {
                        response = await fetch('examples/trees/manifest.json');
                        if (response.ok) {
                            manifestPath = 'examples/trees/';
                        }
                    } catch (e) {
                        // Both paths failed
                    }
                }

                if (!response || !response.ok) {
                    throw new Error('Cannot load manifest - make sure HTML is served via HTTP server');
                }

                const manifest = await response.json();

                if (manifest.length === 0) {
                    content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center; font-size: 12px;">No example trees found</div>';
                    return;
                }

                let html = '';
                manifest.forEach(entry => {
                    html += `
                        <div class="library-item" onclick="loadLocalTree('${entry.file}', '${entry.name.replace(/'/g, "\\'")}', '${manifestPath}')">
                            <div class="library-item-title">${entry.name}</div>
                            <div class="library-item-desc">${entry.description || 'No description'}</div>
                            <div class="library-item-meta">
                                ${entry.tags ? entry.tags.map(t => `<span style="background: #3e3e42; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px;">${t}</span>`).join('') : ''}
                            </div>
                        </div>
                    `;
                });

                content.innerHTML = html;
            } catch (error) {
                content.innerHTML = `<div style="color: #e06c75; padding: 20px; text-align: center; font-size: 11px;">Error loading local examples: ${error.message}<br><br>Make sure the page is served via HTTP (not file://)</div>`;
            }
        }

        async function loadRemoteLibrary() {
            const content = document.getElementById('libraryContent');

            try {
                // Fetch from API
                const response = await fetch(`${API_BASE}/trees/`);
                if (!response.ok) throw new Error('API not available');

                const catalog = await response.json();

                if (catalog.length === 0) {
                    content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center; font-size: 12px;">No trees in remote library</div>';
                    return;
                }

                let html = '';
                catalog.forEach(entry => {
                    html += `
                        <div class="library-item" onclick="loadRemoteTree('${entry.tree_id}', '${entry.tree_name.replace(/'/g, "\\'")}')">
                            <div class="library-item-title">${entry.display_name}</div>
                            <div class="library-item-desc">${entry.description || 'No description'}</div>
                            <div class="library-item-meta">
                                <span style="background: #3e3e42; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px;">v${entry.latest_version}</span>
                                ${entry.tags ? entry.tags.map(t => `<span style="background: #3e3e42; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px;">${t}</span>`).join('') : ''}
                            </div>
                        </div>
                    `;
                });

                content.innerHTML = html;
            } catch (error) {
                content.innerHTML = `<div style="color: #e06c75; padding: 20px; text-align: center; font-size: 11px;">Error: ${error.message}<br><br>Make sure API is running</div>`;
            }
        }

        async function loadLocalTree(filename, treeName, basePath = '../examples/trees/') {
            if (nodes.length > 0 && !confirm(`Load "${treeName}"? Current tree will be lost if not saved.`)) {
                return;
            }

            try {
                const response = await fetch(`${basePath}${filename}`);
                if (!response.ok) throw new Error('Cannot load tree file');

                const treeData = await response.json();
                await importTreeFromJSON(treeData);
                updateStatus(`Loaded: ${treeName}`);
            } catch (error) {
                alert(`Error loading tree: ${error.message}`);
            }
        }

        async function loadRemoteTree(treeId, treeName) {
            if (nodes.length > 0 && !confirm(`Load "${treeName}"? Current tree will be lost if not saved.`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/trees/${treeId}`);
                if (!response.ok) throw new Error('Cannot load tree from API');

                const treeData = await response.json();
                await importTreeFromJSON(treeData);
                updateStatus(`Loaded from API: ${treeName}`);
            } catch (error) {
                alert(`Error loading tree from API: ${error.message}`);
            }
        }

        async function openFolderPicker() {
            try {
                // Check if File System Access API is supported
                if (!('showDirectoryPicker' in window)) {
                    alert('Folder picker is not supported in your browser. Please use Chrome, Edge, or another Chromium-based browser.');
                    return;
                }

                // Open folder picker
                const dirHandle = await window.showDirectoryPicker();

                // Load trees from the selected folder
                await loadTreesFromFolder(dirHandle);

            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error opening folder:', error);
                    alert(`Error opening folder: ${error.message}`);
                }
            }
        }

        async function loadTreesFromFolder(dirHandle) {
            const content = document.getElementById('libraryContent');
            content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center;">Scanning folder...</div>';

            try {
                const trees = [];

                // Scan directory for .json files
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.json')) {
                        try {
                            const file = await entry.getFile();
                            const text = await file.text();
                            const treeData = JSON.parse(text);

                            // Check if it's a valid tree (has metadata)
                            if (treeData.metadata) {
                                trees.push({
                                    name: treeData.metadata.name || entry.name,
                                    description: treeData.metadata.description || 'No description',
                                    tags: treeData.metadata.tags || [],
                                    version: treeData.metadata.version || '1.0.0',
                                    file: entry,
                                    treeData: treeData
                                });
                            }
                        } catch (e) {
                            // Skip invalid JSON files
                            console.warn(`Skipping invalid file: ${entry.name}`, e);
                        }
                    }
                }

                if (trees.length === 0) {
                    content.innerHTML = '<div style="color: #858585; padding: 20px; text-align: center; font-size: 12px;">No valid tree files found in folder</div>';
                    return;
                }

                // Display trees
                let html = `<div style="padding: 10px; background: #2d2d30; margin: -15px -15px 10px -15px; border-bottom: 1px solid #3e3e42; font-size: 11px; color: #858585;">
                    üìÅ ${dirHandle.name} (${trees.length} tree${trees.length !== 1 ? 's' : ''})
                </div>`;

                trees.forEach((tree, index) => {
                    html += `
                        <div class="library-item" onclick="loadTreeFromFolder(${index})">
                            <div class="library-item-title">${tree.name}</div>
                            <div class="library-item-desc">${tree.description}</div>
                            <div class="library-item-meta">
                                <span style="background: #3e3e42; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px;">v${tree.version}</span>
                                ${tree.tags.map(t => `<span style="background: #3e3e42; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px;">${t}</span>`).join('')}
                            </div>
                        </div>
                    `;
                });

                content.innerHTML = html;

                // Store trees in global variable for loading
                window.folderTrees = trees;

            } catch (error) {
                content.innerHTML = `<div style="color: #e06c75; padding: 20px; text-align: center; font-size: 11px;">Error scanning folder: ${error.message}</div>`;
            }
        }

        async function loadTreeFromFolder(index) {
            if (!window.folderTrees || !window.folderTrees[index]) {
                alert('Error: Tree not found in folder cache');
                return;
            }

            const tree = window.folderTrees[index];

            if (nodes.length > 0 && !confirm(`Load "${tree.name}"? Current tree will be lost if not saved.`)) {
                return;
            }

            try {
                await importTreeFromJSON(tree.treeData);
                updateStatus(`Loaded: ${tree.name}`);
            } catch (error) {
                alert(`Error loading tree: ${error.message}`);
            }
        }

        function filterPalette() {
            const search = document.getElementById('paletteSearch').value.toLowerCase();
            document.querySelectorAll('.node-item').forEach(item => {
                const searchText = item.dataset.search + ' ' + item.querySelector('.node-item-title').textContent.toLowerCase();
                item.style.display = searchText.includes(search) ? 'block' : 'none';
            });
        }

        function filterLibrary() {
            const search = document.getElementById('librarySearch').value.toLowerCase();
            document.querySelectorAll('.library-item').forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(search) ? 'block' : 'none';
            });
        }

        function showConnectHint() {
            const hint = document.getElementById('canvasHint');
            hint.textContent = 'üîó Connect Mode: Click parent node (composite/decorator), then click child node';
            hint.classList.add('connect-mode');
            hint.style.display = 'block';
        }

        function hideConnectHint() {
            const hint = document.getElementById('canvasHint');
            if (nodes.length === 0) {
                hint.textContent = 'Quick Start: Drag nodes from palette, click üîóConnect, or load ü§ñExample';
                hint.classList.remove('connect-mode');
                hint.style.display = 'block';
            } else {
                hint.style.display = 'none';
            }
        }

        function hideQuickStartHint() {
            const hint = document.getElementById('canvasHint');
            hint.style.display = 'none';
        }

        function updateStatus(message) {
            document.getElementById('statusMessage').textContent = message;
            setTimeout(() => {
                document.getElementById('statusMessage').textContent = 'Ready';
            }, 3000);
        }

        function updateTreeNameDisplay() {
            document.getElementById('treeNameDisplay').innerHTML = `<strong>${currentTreeName}</strong>`;
        }

        // Toast Notification System
        function showToast(message, type = 'info', duration = 2000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');

            const icons = {
                success: '‚úì',
                error: '‚úó',
                warning: '‚ö†',
                info: '‚Ñπ'
            };

            const colors = {
                success: '#4caf50',
                error: '#f44336',
                warning: '#ff9800',
                info: '#4fc1ff'
            };

            toast.style.cssText = `
                background: ${colors[type] || colors.info};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                display: flex;
                align-items: center;
                gap: 10px;
                pointer-events: auto;
                animation: slideInRight 0.3s ease-out;
                min-width: 200px;
                max-width: 400px;
            `;

            toast.innerHTML = `
                <span style="font-size: 16px;">${icons[type] || icons.info}</span>
                <span>${message}</span>
            `;

            container.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => {
                    container.removeChild(toast);
                }, 300);
            }, duration);
        }

        function updateBreadcrumbPath() {
            const pathText = document.getElementById('pathText');

            if (!selectedNode) {
                pathText.textContent = '';
                return;
            }

            // Build path from root to selected node
            const path = [];
            let current = selectedNode;
            while (current) {
                path.unshift(current.name);
                current = current.parent;
            }

            // Format path with separators
            const formattedPath = path.join(' ‚Üí ');
            pathText.textContent = `Path: ${formattedPath}`;
            pathText.title = formattedPath; // Tooltip for long paths
        }

        // Animation loop for search results pulse
        let searchAnimationId = null;
        function animateSearchResults() {
            if (searchResults.size > 0) {
                render();
                searchAnimationId = requestAnimationFrame(animateSearchResults);
            } else {
                if (searchAnimationId) {
                    cancelAnimationFrame(searchAnimationId);
                    searchAnimationId = null;
                }
            }
        }

        // Search functionality
        function searchNodes(query) {
            searchResults.clear();

            if (!query || query.trim() === '') {
                render();
                updateStatus('Search cleared');
                return;
            }

            const lowerQuery = query.toLowerCase().trim();
            let matchCount = 0;

            nodes.forEach(node => {
                // Search in node name and type
                const nameMatch = node.name.toLowerCase().includes(lowerQuery);
                const typeMatch = node.type.toLowerCase().includes(lowerQuery);

                // Also search in config values
                let configMatch = false;
                try {
                    const configStr = JSON.stringify(node.config).toLowerCase();
                    configMatch = configStr.includes(lowerQuery);
                } catch (e) { }

                if (nameMatch || typeMatch || configMatch) {
                    searchResults.add(node);
                    matchCount++;
                }
            });

            // Start animation loop for pulse effect
            if (matchCount > 0 && !searchAnimationId) {
                animateSearchResults();
            }

            render();

            if (matchCount > 0) {
                updateStatus(`Found ${matchCount} matching node(s)`);

                // Auto-focus first result if only one match
                if (matchCount === 1) {
                    const firstResult = Array.from(searchResults)[0];
                    // Center viewport on the result
                    viewportX = (canvas.width / 2) - (firstResult.x + 75) * viewportScale;
                    viewportY = (canvas.height / 2) - (firstResult.y + 30) * viewportScale;
                    render();
                }
            } else {
                updateStatus('No nodes found');
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // Click outside modal to close
        document.querySelectorAll('.modal-overlay').forEach(overlay => {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.classList.remove('active');
                }
            });
        });

        // Command Palette
        let commandPaletteIndex = 0;
        const commands = [
            { name: 'New Tree', shortcut: 'Ctrl+N', action: () => newTree(), category: 'File' },
            { name: 'Save to Library', shortcut: 'Ctrl+S', action: () => saveToLibrary(), category: 'File' },
            { name: 'Load from Library', shortcut: '', action: () => openLoadModal(), category: 'File' },
            { name: 'Download as JSON', shortcut: '', action: () => exportTree(), category: 'File' },
            { name: 'Publish to API', shortcut: '', action: () => saveToAPI(), category: 'File' },
            { name: 'Get Python Code', shortcut: '', action: () => openCopyPythonModal(), category: 'File' },
            { name: 'Import from JSON File', shortcut: '', action: () => importFromJSON(), category: 'File' },

            { name: 'Undo', shortcut: 'Ctrl+Z', action: () => undo(), category: 'Edit' },
            { name: 'Redo', shortcut: 'Ctrl+Y', action: () => redo(), category: 'Edit' },
            { name: 'Copy Node', shortcut: 'Ctrl+C', action: () => copySelected(), category: 'Edit' },
            { name: 'Copy Node Path', shortcut: 'Ctrl+Shift+C', action: () => copyNodePath(), category: 'Edit' },
            { name: 'Cut Node', shortcut: 'Ctrl+X', action: () => cutSelected(), category: 'Edit' },
            { name: 'Paste Node', shortcut: 'Ctrl+V', action: () => pasteFromClipboard(), category: 'Edit' },
            { name: 'Duplicate Node', shortcut: 'Ctrl+D', action: () => duplicateSelected(), category: 'Edit' },
            { name: 'Delete Node', shortcut: 'Delete', action: () => selectedNode ? deleteSelectedNode() : null, category: 'Edit' },
            { name: 'Select All Nodes', shortcut: 'Ctrl+A', action: () => selectAll(), category: 'Edit' },
            { name: 'Clear Selection', shortcut: 'Esc', action: () => { selectedNode = null; selectedNodes.clear(); render(); }, category: 'Edit' },

            { name: 'Auto Layout', shortcut: 'Ctrl+L', action: () => autoLayout(), category: 'View' },
            { name: 'Toggle Grid', shortcut: 'Ctrl+G', action: () => toggleGrid(), category: 'View' },
            { name: 'Zoom to Fit', shortcut: 'Ctrl+0', action: () => zoomFit(), category: 'View' },
            { name: 'Zoom In', shortcut: '+', action: () => zoomIn(), category: 'View' },
            { name: 'Zoom Out', shortcut: '-', action: () => zoomOut(), category: 'View' },
            { name: 'Reset Zoom', shortcut: '', action: () => { viewportScale = 1; viewportX = 0; viewportY = 0; render(); }, category: 'View' },

            { name: 'Validate Tree', shortcut: 'Ctrl+Shift+V', action: () => validateTree(), category: 'Tree' },
            { name: 'Toggle Connect Mode', shortcut: 'S', action: () => toggleConnectMode(), category: 'Tree' },
            { name: 'Rename Node', shortcut: 'F2', action: () => selectedNode ? startInlineRename(selectedNode, (selectedNode.x * viewportScale) + viewportX + 75, (selectedNode.y * viewportScale) + viewportY + 30) : null, category: 'Tree' },
            { name: 'Search Nodes', shortcut: 'Ctrl+F', action: () => { document.getElementById('nodeSearchInput').focus(); document.getElementById('nodeSearchInput').select(); }, category: 'Tree' },

            { name: 'Show Keyboard Shortcuts', shortcut: 'F1 or ?', action: () => document.getElementById('shortcutsModal').classList.add('active'), category: 'Help' },
        ];

        function openCommandPalette() {
            document.getElementById('commandPaletteModal').classList.add('active');
            commandPaletteIndex = 0;
            document.getElementById('commandPaletteInput').value = '';
            filterCommands();
            setTimeout(() => {
                document.getElementById('commandPaletteInput').focus();
            }, 100);
        }

        function filterCommands() {
            const input = document.getElementById('commandPaletteInput').value.toLowerCase();
            const resultsDiv = document.getElementById('commandPaletteResults');

            const filtered = commands.filter(cmd =>
                cmd.name.toLowerCase().includes(input) ||
                cmd.category.toLowerCase().includes(input) ||
                cmd.shortcut.toLowerCase().includes(input)
            );

            if (filtered.length === 0) {
                resultsDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #858585;">No commands found</div>';
                return;
            }

            commandPaletteIndex = Math.min(commandPaletteIndex, filtered.length - 1);

            let html = '';
            let currentCategory = '';
            filtered.forEach((cmd, idx) => {
                if (cmd.category !== currentCategory) {
                    currentCategory = cmd.category;
                    html += `<div style="padding: 8px 12px; color: #4fc1ff; font-size: 11px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; margin-top: ${idx > 0 ? '10px' : '0'};">${currentCategory}</div>`;
                }

                const isSelected = idx === commandPaletteIndex;
                html += `
                    <div class="command-item"
                         data-index="${idx}"
                         onclick="executeCommand(${idx})"
                         style="padding: 10px 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-radius: 4px; ${isSelected ? 'background: #4fc1ff; color: #1e1e1e;' : 'background: transparent; color: #e0e0e0;'} transition: all 0.1s;">
                        <span>${cmd.name}</span>
                        ${cmd.shortcut ? `<kbd style="opacity: 0.7; font-size: 11px;">${cmd.shortcut}</kbd>` : ''}
                    </div>
                `;
            });

            resultsDiv.innerHTML = html;
        }

        function handleCommandPaletteKey(event) {
            const resultsDiv = document.getElementById('commandPaletteResults');
            const commandItems = resultsDiv.querySelectorAll('.command-item');

            if (event.key === 'Escape') {
                event.preventDefault();
                closeModal('commandPaletteModal');
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                commandPaletteIndex = (commandPaletteIndex + 1) % commandItems.length;
                filterCommands();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                commandPaletteIndex = (commandPaletteIndex - 1 + commandItems.length) % commandItems.length;
                filterCommands();
            } else if (event.key === 'Enter') {
                event.preventDefault();
                if (commandItems.length > 0) {
                    executeCommand(commandPaletteIndex);
                }
            }
        }

        function executeCommand(index) {
            const input = document.getElementById('commandPaletteInput').value.toLowerCase();
            const filtered = commands.filter(cmd =>
                cmd.name.toLowerCase().includes(input) ||
                cmd.category.toLowerCase().includes(input) ||
                cmd.shortcut.toLowerCase().includes(input)
            );

            if (filtered[index]) {
                closeModal('commandPaletteModal');
                filtered[index].action();
            }
        }

        // Copy/Paste/Duplicate Operations
        function copyNodeSubtree(node) {
            // Deep copy node and all its children with new IDs
            const copy = {
                type: node.type,
                category: node.category,
                name: node.name + ' (Copy)',
                config: JSON.parse(JSON.stringify(node.config)),
                collapsed: false,
                children: []
            };

            // Recursively copy children
            node.children.forEach(childRef => {
                const child = nodes.find(n => n.id === childRef.id);
                if (child) {
                    copy.children.push(copyNodeSubtree(child));
                }
            });

            return copy;
        }

        function pasteNodeSubtree(nodeDef, x, y, parent = null) {
            // Create node from definition
            const node = {
                id: nextNodeId++,
                type: nodeDef.type,
                category: nodeDef.category,
                name: nodeDef.name,
                x: x,
                y: y,
                config: JSON.parse(JSON.stringify(nodeDef.config)),
                children: [],
                parent: parent,
                collapsed: false
            };

            nodes.push(node);

            // Recursively create children
            nodeDef.children.forEach((childDef, index) => {
                const childNode = pasteNodeSubtree(childDef, x + (index - nodeDef.children.length / 2) * 200, y + 150, node);
                node.children.push(childNode);
            });

            return node;
        }

        function copyNodePath() {
            if (!selectedNode) {
                updateStatus('No node selected');
                return;
            }

            // Build path from root to selected node
            const path = [];
            let current = selectedNode;
            while (current) {
                path.unshift(current.name);
                current = current.parent;
            }

            const pathString = path.join(' ‚Üí ');

            // Copy to clipboard
            navigator.clipboard.writeText(pathString).then(() => {
                updateStatus(`‚úì Copied path: ${pathString}`);
            }).catch(() => {
                updateStatus('Failed to copy to clipboard');
            });
        }

        function copySelected() {
            if (selectedNodes.size === 0) {
                updateStatus('No nodes selected to copy');
                return;
            }

            // For multi-select, copy all selected nodes
            if (selectedNodes.size === 1) {
                clipboard = copyNodeSubtree(selectedNode);
                updateStatus(`Copied ${selectedNode.name}`);
            } else {
                // Copy multiple nodes as array
                clipboard = {
                    multipleNodes: true,
                    nodes: Array.from(selectedNodes).map(node => copyNodeSubtree(node))
                };
                updateStatus(`Copied ${selectedNodes.size} nodes`);
            }
        }

        function cutSelected() {
            if (selectedNodes.size === 0) {
                updateStatus('No nodes selected to cut');
                return;
            }

            // Copy to clipboard first
            copySelected();

            // Then delete
            deleteSelectedNodes();

            updateStatus(`Cut ${selectedNodes.size} node(s) to clipboard`);
        }

        function pasteFromClipboard() {
            if (!clipboard) {
                updateStatus('Clipboard is empty');
                return;
            }

            // Paste at center of viewport
            const centerX = (-viewportX + canvas.width / 2) / viewportScale;
            const centerY = (-viewportY + canvas.height / 2) / viewportScale;

            if (clipboard.multipleNodes) {
                // Paste multiple nodes
                selectedNodes.clear();
                clipboard.nodes.forEach((nodeDef, index) => {
                    const offsetY = index * 100; // Stack nodes vertically
                    const pastedNode = pasteNodeSubtree(nodeDef, centerX, centerY + offsetY);
                    selectedNodes.add(pastedNode);
                    if (index === 0) selectedNode = pastedNode;
                });
                updateStatus(`Pasted ${clipboard.nodes.length} nodes`);
            } else {
                // Paste single node
                const pastedNode = pasteNodeSubtree(clipboard, centerX, centerY);
                selectNode(pastedNode);
                updateStatus(`Pasted ${clipboard.name}`);
            }

            saveHistory();
            render();
        }

        function duplicateSelected() {
            if (selectedNodes.size === 0) {
                updateStatus('No nodes selected to duplicate');
                return;
            }

            const newSelectedNodes = new Set();

            Array.from(selectedNodes).forEach((node, index) => {
                const copy = copyNodeSubtree(node);
                const offsetX = 50;
                const offsetY = 50 + (index * 20); // Stagger multiple duplicates
                const duplicatedNode = pasteNodeSubtree(copy, node.x + offsetX, node.y + offsetY);
                newSelectedNodes.add(duplicatedNode);
            });

            // Select the duplicated nodes
            selectedNodes.clear();
            newSelectedNodes.forEach(node => selectedNodes.add(node));
            selectedNode = Array.from(selectedNodes)[0];

            saveHistory();
            render();
            updateStatus(`Duplicated ${newSelectedNodes.size} node(s)`);
        }

        function selectAll() {
            selectedNodes.clear();
            nodes.forEach(node => selectedNodes.add(node));
            updateStatus(`Selected ${nodes.length} nodes`);
            render();
        }

        function deleteSelectedNodes() {
            if (selectedNodes.size === 0) {
                updateStatus('No nodes selected');
                return;
            }

            const count = selectedNodes.size;
            selectedNodes.forEach(node => {
                if (node.parent) {
                    const parentNode = nodes.find(n => n.id === node.parent.id);
                    if (parentNode && parentNode.children) {
                        parentNode.children = parentNode.children.filter(c => c.id !== node.id);
                    }
                }

                function deleteRecursive(n) {
                    for (let childRef of n.children) {
                        const child = nodes.find(nd => nd.id === childRef.id);
                        if (child) deleteRecursive(child);
                    }
                    nodes = nodes.filter(nd => nd !== n);
                }
                deleteRecursive(node);
            });

            selectedNodes.clear();
            selectedNode = null;
            saveHistory();
            showProperties(null);
            render();
            updateStatus(`Deleted ${count} nodes`);
        }

        // ==================== EXECUTION SIMULATOR ====================
        let simulationState = {
            running: false,
            tick: 0,
            speed: 1000, // ms between ticks (default 1 tick per second)
            tps: 1, // ticks per second
            intervalId: null,
            mode: 'auto', // 'auto' or 'manual'
            nodeStates: new Map(), // nodeId -> {status, ticksRun, lastTick}
            blackboard: new Map(), // variable -> value
            history: [] // Array of {tick, nodeStates, blackboard}
        };

        // Timeline scrubber state
        let timelineState = {
            playbackTick: -1,  // -1 means "live", >= 0 means viewing history
            maxHistory: 100,   // Keep last 100 ticks
            isDragging: false,
            wasRunningBeforeScrub: false
        };

        const NodeStatus = {
            IDLE: 'IDLE',
            RUNNING: 'RUNNING',
            SUCCESS: 'SUCCESS',
            FAILURE: 'FAILURE'
        };

        function initializeSimulation() {
            // Reset all node states
            simulationState.nodeStates.clear();
            nodes.forEach(node => {
                simulationState.nodeStates.set(node.id, {
                    status: NodeStatus.IDLE,
                    ticksRun: 0,
                    lastTick: -1
                });
            });

            // Clear blackboard completely
            simulationState.blackboard.clear();

            // Initialize blackboard with example variables based on tree nodes
            // Only add defaults if the tree uses them
            const hasSetBlackboard = nodes.some(n => n.type === 'SetBlackboardVariable');
            if (!hasSetBlackboard) {
                // Add some example variables for demo purposes
                simulationState.blackboard.set('battery_level', 100);
                simulationState.blackboard.set('target_position', {x: 10, y: 20});
                simulationState.blackboard.set('enemies_detected', false);
            }

            simulationState.tick = 0;
            simulationState.history = [];
        }

        function toggleSimulation() {
            if (simulationState.running) {
                pauseSimulation();
            } else {
                startSimulation();
            }
        }

        function startSimulation() {
            if (nodes.length === 0) {
                showToast('No tree to simulate', 'warning');
                return;
            }

            // Validate tree before starting simulation
            const validation = validateTree();
            if (!validation.passed) {
                showToast(`Cannot start simulation: Tree has ${validation.errors.length} error(s). See validation panel.`, 'error');
                return;
            }

            // Only allow auto-play in auto mode
            if (simulationState.mode !== 'auto') {
                showToast('Switch to Auto mode to use Run button', 'warning');
                return;
            }

            if (simulationState.tick === 0) {
                initializeSimulation();
            }

            simulationState.running = true;
            document.getElementById('simPlayBtn').innerHTML = '<span class="toolbar-icon">‚è∏</span> Pause';
            document.getElementById('simPlayBtn').style.background = '#ff9800';
            document.getElementById('simStepBtn').disabled = true;
            document.getElementById('simResetBtn').disabled = false;

            // Run ticks at specified speed
            simulationState.intervalId = setInterval(() => {
                tickSimulation();
            }, simulationState.speed);

            showToast('Simulation started', 'success');
        }

        function pauseSimulation() {
            simulationState.running = false;
            clearInterval(simulationState.intervalId);
            document.getElementById('simPlayBtn').innerHTML = '<span class="toolbar-icon">‚ñ∂</span> Run';
            document.getElementById('simPlayBtn').style.background = '#4caf50';
            // Only enable step button if not in auto mode
            document.getElementById('simStepBtn').disabled = simulationState.mode === 'auto';
            showToast('Simulation paused', 'info');
        }

        function stepSimulation() {
            if (nodes.length === 0) {
                showToast('No tree to simulate', 'warning');
                return;
            }

            // Validate tree before first step
            if (simulationState.tick === 0) {
                const validation = validateTree();
                if (!validation.passed) {
                    showToast(`Cannot start simulation: Tree has ${validation.errors.length} error(s). See validation panel.`, 'error');
                    return;
                }
                initializeSimulation();
                document.getElementById('simResetBtn').disabled = false;
            }

            tickSimulation();
        }

        function resetSimulation() {
            pauseSimulation();
            initializeSimulation();
            render();
            updateBlackboardDisplay();
            updateSimTickCounter();
            document.getElementById('simPlayBtn').innerHTML = '<span class="toolbar-icon">‚ñ∂</span> Run';
            document.getElementById('simPlayBtn').style.background = '#4caf50';
            document.getElementById('simStepBtn').disabled = simulationState.mode === 'auto';
            document.getElementById('simResetBtn').disabled = true;
            showToast('Simulation reset', 'info');
        }

        function updateSimTickCounter() {
            const counter = document.getElementById('simTickCounter');
            if (counter) {
                counter.textContent = `Tick: ${simulationState.tick}`;
            }
        }

        function toggleSimulationMode() {
            const toggle = document.getElementById('simModeToggle');
            const label = document.getElementById('simModeLabel');
            const playBtn = document.getElementById('simPlayBtn');
            const stepBtn = document.getElementById('simStepBtn');
            const speedSlider = document.getElementById('simSpeedSlider');
            const speedInput = document.getElementById('simSpeedInput');

            if (toggle.checked) {
                // Auto mode
                simulationState.mode = 'auto';
                label.textContent = 'Auto';
                playBtn.disabled = false;
                speedSlider.disabled = false;
                speedInput.disabled = false;
                stepBtn.disabled = true;
                playBtn.style.opacity = '1';
                speedSlider.style.opacity = '1';
                speedInput.style.opacity = '1';
                stepBtn.style.opacity = '0.5';
            } else {
                // Manual mode
                simulationState.mode = 'manual';
                label.textContent = 'Manual';
                playBtn.disabled = true;
                speedSlider.disabled = true;
                speedInput.disabled = true;
                stepBtn.disabled = false;
                playBtn.style.opacity = '0.5';
                speedSlider.style.opacity = '0.5';
                speedInput.style.opacity = '0.5';
                stepBtn.style.opacity = '1';

                // Stop simulation if running
                if (simulationState.running) {
                    pauseSimulation();
                }
            }
        }

        function tickSimulation() {
            simulationState.tick++;

            // Find root node
            const roots = nodes.filter(n => !n.parent);
            if (roots.length === 0) return;

            // Execute tree from root
            executeNode(roots[0]);

            // Save history snapshot
            simulationState.history.push({
                tick: simulationState.tick,
                nodeStates: new Map(simulationState.nodeStates),
                blackboard: new Map(simulationState.blackboard)
            });

            // Limit history size
            if (simulationState.history.length > timelineState.maxHistory) {
                simulationState.history.shift();
            }

            // Update display
            render();
            updateBlackboardDisplay();
            updateSimTickCounter();

            // Update timeline if visible
            if (timelineState.playbackTick === -1) {  // Only if in "live" mode
                updateTimeline();
            }
        }

        function executeNode(node) {
            const state = simulationState.nodeStates.get(node.id);

            state.ticksRun++;
            state.lastTick = simulationState.tick;

            // Simple execution logic based on node type
            switch (node.type) {
                case 'Sequence':
                    state.status = executeSequence(node);
                    break;
                case 'Selector':
                    state.status = executeSelector(node);
                    break;
                case 'Parallel':
                    state.status = executeParallel(node);
                    break;
                case 'Success':
                    state.status = NodeStatus.SUCCESS;
                    break;
                case 'Failure':
                    state.status = NodeStatus.FAILURE;
                    break;
                case 'Running':
                    state.status = NodeStatus.RUNNING;
                    break;
                case 'Inverter':
                    state.status = executeInverter(node);
                    break;
                case 'Retry':
                case 'Timeout':
                    // Execute child
                    if (node.children.length > 0) {
                        const child = nodes.find(n => n.id === node.children[0].id);
                        if (child) {
                            state.status = executeNode(child);
                        }
                    }
                    break;
                case 'SetBlackboardVariable':
                    // Set blackboard variable
                    if (node.config && node.config.variable) {
                        simulationState.blackboard.set(node.config.variable, node.config.value);
                    }
                    state.status = NodeStatus.SUCCESS;
                    break;
                case 'CheckBlackboardVariableExists':
                    // Check if variable exists
                    if (node.config && node.config.variable) {
                        state.status = simulationState.blackboard.has(node.config.variable)
                            ? NodeStatus.SUCCESS : NodeStatus.FAILURE;
                    } else {
                        state.status = NodeStatus.FAILURE;
                    }
                    break;
                case 'CheckBlackboardVariableValue':
                    // Check blackboard variable value
                    if (node.config && node.config.variable && node.config.operator) {
                        const value = simulationState.blackboard.get(node.config.variable);
                        const expected = node.config.value;
                        let result = false;

                        switch (node.config.operator) {
                            case '==': result = value == expected; break;
                            case '!=': result = value != expected; break;
                            case '<': result = value < expected; break;
                            case '>': result = value > expected; break;
                            case '<=': result = value <= expected; break;
                            case '>=': result = value >= expected; break;
                        }

                        state.status = result ? NodeStatus.SUCCESS : NodeStatus.FAILURE;
                    } else {
                        state.status = NodeStatus.FAILURE;
                    }
                    break;
                default:
                    // For other actions, randomly succeed/fail for demo
                    state.status = Math.random() > 0.3 ? NodeStatus.SUCCESS : NodeStatus.FAILURE;
            }

            return state.status;
        }

        function executeSequence(node) {
            for (const childRef of node.children) {
                const child = nodes.find(n => n.id === childRef.id);
                if (child) {
                    const childStatus = executeNode(child);
                    if (childStatus === NodeStatus.FAILURE) {
                        return NodeStatus.FAILURE;
                    }
                    if (childStatus === NodeStatus.RUNNING) {
                        return NodeStatus.RUNNING;
                    }
                }
            }
            return NodeStatus.SUCCESS;
        }

        function executeSelector(node) {
            for (const childRef of node.children) {
                const child = nodes.find(n => n.id === childRef.id);
                if (child) {
                    const childStatus = executeNode(child);
                    if (childStatus === NodeStatus.SUCCESS) {
                        return NodeStatus.SUCCESS;
                    }
                    if (childStatus === NodeStatus.RUNNING) {
                        return NodeStatus.RUNNING;
                    }
                }
            }
            return NodeStatus.FAILURE;
        }

        function executeParallel(node) {
            let successCount = 0;
            let failureCount = 0;

            for (const childRef of node.children) {
                const child = nodes.find(n => n.id === childRef.id);
                if (child) {
                    const childStatus = executeNode(child);
                    if (childStatus === NodeStatus.SUCCESS) successCount++;
                    if (childStatus === NodeStatus.FAILURE) failureCount++;
                }
            }

            // Simple policy: succeed if all succeed
            if (successCount === node.children.length) return NodeStatus.SUCCESS;
            if (failureCount > 0) return NodeStatus.FAILURE;
            return NodeStatus.RUNNING;
        }

        function executeInverter(node) {
            if (node.children.length > 0) {
                const child = nodes.find(n => n.id === node.children[0].id);
                if (child) {
                    const childStatus = executeNode(child);
                    if (childStatus === NodeStatus.SUCCESS) return NodeStatus.FAILURE;
                    if (childStatus === NodeStatus.FAILURE) return NodeStatus.SUCCESS;
                    return childStatus;
                }
            }
            return NodeStatus.FAILURE;
        }

        function updateSimSpeedFromTPS(tps) {
            tps = parseFloat(tps);
            if (isNaN(tps) || tps <= 0) tps = 0.1;
            if (tps > 100) tps = 100;

            // Convert TPS to milliseconds between ticks
            simulationState.speed = 1000 / tps;
            simulationState.tps = tps;

            // Update both slider and input
            document.getElementById('simSpeedSlider').value = tps;
            document.getElementById('simSpeedInput').value = tps.toFixed(1);

            if (simulationState.running) {
                // Restart with new speed
                clearInterval(simulationState.intervalId);
                simulationState.intervalId = setInterval(() => {
                    tickSimulation();
                }, simulationState.speed);
            }
        }

        function updateSimSpeedFromSlider(tps) {
            updateSimSpeedFromTPS(tps);
        }

        function toggleBlackboard() {
            const panel = document.getElementById('blackboardPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            if (panel.style.display === 'block') {
                updateBlackboardDisplay();
            }
        }

        function updateBlackboardDisplay() {
            const content = document.getElementById('blackboardContent');
            if (simulationState.blackboard.size === 0) {
                content.innerHTML = '<div style="color: #858585; font-size: 12px; text-align: center; padding: 20px;">No variables</div>';
                return;
            }

            let html = '<div style="font-size: 12px;">';
            simulationState.blackboard.forEach((value, key) => {
                const valueStr = typeof value === 'object' ? JSON.stringify(value) : String(value);
                html += `
                    <div style="padding: 8px; border-bottom: 1px solid #3e3e42; display: flex; justify-content: space-between;">
                        <strong style="color: #4fc1ff;">${key}</strong>
                        <span style="color: #d4d4d4;">${valueStr}</span>
                    </div>
                `;
            });
            html += '</div>';
            content.innerHTML = html;
        }

        // ==================== EXECUTION TIMELINE ====================

        function showTimeline() {
            const scrubber = document.getElementById('timelineScrubber');
            if (simulationState.history.length > 0) {
                scrubber.style.display = 'flex';
                updateTimeline();
            }
        }

        function hideTimeline() {
            const scrubber = document.getElementById('timelineScrubber');
            scrubber.style.display = 'none';
            timelineState.playbackTick = -1;
        }

        function updateTimeline() {
            if (simulationState.history.length === 0) return;

            const scrubber = document.getElementById('timelineScrubber');
            const handle = document.getElementById('timelineHandle');
            const track = document.getElementById('timelineTrack');
            const infoSpan = document.getElementById('timelineTickInfo');
            const prevBtn = document.getElementById('prevTickBtn');
            const nextBtn = document.getElementById('nextTickBtn');

            // Show timeline if hidden and we have history
            if (simulationState.history.length > 0) {
                scrubber.style.display = 'flex';
            }

            // Get current tick (either playback or latest)
            const currentTick = timelineState.playbackTick >= 0
                ? timelineState.playbackTick
                : simulationState.history.length - 1;

            const historyLength = simulationState.history.length;

            // Update handle position
            const trackWidth = track.offsetWidth - 12; // minus handle width
            const position = (currentTick / Math.max(historyLength - 1, 1)) * trackWidth;
            handle.style.left = `${position}px`;

            // Update info text
            const tickNumber = simulationState.history[currentTick]?.tick || 0;
            const mode = timelineState.playbackTick >= 0 ? '‚è∏' : '‚ñ∂';
            infoSpan.innerHTML = `${mode} Tick <strong>${tickNumber}</strong> / ${simulationState.tick} (${historyLength} in buffer)`;

            // Update button states
            prevBtn.disabled = currentTick <= 0;
            nextBtn.disabled = currentTick >= historyLength - 1;

            // Render timeline visualization
            renderTimelineCanvas();
        }

        function renderTimelineCanvas() {
            const canvas = document.getElementById('timelineCanvas');
            const track = document.getElementById('timelineTrack');

            // Resize canvas to match track
            canvas.width = track.offsetWidth;
            canvas.height = 20;

            const ctx = canvas.getContext('2d');
            const historyLength = simulationState.history.length;

            if (historyLength === 0) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw tick markers
            const markerWidth = Math.max(2, canvas.width / historyLength);

            simulationState.history.forEach((snapshot, index) => {
                const x = (index / historyLength) * canvas.width;

                // Determine color based on node states in this tick
                let hasFailure = false;
                let hasRunning = false;
                let allSuccess = true;

                snapshot.nodeStates.forEach((state, nodeId) => {
                    if (state.status === 'FAILURE') hasFailure = true;
                    if (state.status === 'RUNNING') hasRunning = true;
                    if (state.status !== 'SUCCESS' && state.status !== 'IDLE') allSuccess = false;
                });

                // Set color
                if (hasFailure) {
                    ctx.fillStyle = '#e06c75'; // Red
                } else if (hasRunning) {
                    ctx.fillStyle = '#d19a66'; // Yellow
                } else if (allSuccess) {
                    ctx.fillStyle = '#98c379'; // Green
                } else {
                    ctx.fillStyle = '#858585'; // Gray
                }

                // Draw marker
                ctx.fillRect(x, 5, markerWidth, 10);
            });

            // Draw current position indicator
            const currentTick = timelineState.playbackTick >= 0
                ? timelineState.playbackTick
                : historyLength - 1;
            const currentX = (currentTick / historyLength) * canvas.width;

            ctx.strokeStyle = '#4fc1ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(currentX, 0);
            ctx.lineTo(currentX, 20);
            ctx.stroke();
        }

        function prevTick() {
            if (simulationState.history.length === 0) return;

            const currentTick = timelineState.playbackTick >= 0
                ? timelineState.playbackTick
                : simulationState.history.length - 1;

            if (currentTick > 0) {
                scrubToTick(currentTick - 1);
            }
        }

        function nextTick() {
            if (simulationState.history.length === 0) return;

            const currentTick = timelineState.playbackTick >= 0
                ? timelineState.playbackTick
                : simulationState.history.length - 1;

            if (currentTick < simulationState.history.length - 1) {
                scrubToTick(currentTick + 1);
            } else {
                // Return to live mode
                returnToLive();
            }
        }

        function scrubToTick(tickIndex) {
            if (tickIndex < 0 || tickIndex >= simulationState.history.length) return;

            // Pause simulation if running
            if (timelineState.playbackTick === -1 && simulationState.running) {
                timelineState.wasRunningBeforeScrub = true;
                pauseSimulation();
            }

            timelineState.playbackTick = tickIndex;

            // Restore state from history
            const snapshot = simulationState.history[tickIndex];
            simulationState.nodeStates = new Map(snapshot.nodeStates);
            simulationState.blackboard = new Map(snapshot.blackboard);

            // Update displays
            render();
            updateBlackboardDisplay();
            updateTimeline();
        }

        function returnToLive() {
            timelineState.playbackTick = -1;

            // Restore latest state
            if (simulationState.history.length > 0) {
                const latest = simulationState.history[simulationState.history.length - 1];
                simulationState.nodeStates = new Map(latest.nodeStates);
                simulationState.blackboard = new Map(latest.blackboard);
            }

            // Resume simulation if it was running
            if (timelineState.wasRunningBeforeScrub) {
                startSimulation();
                timelineState.wasRunningBeforeScrub = false;
            }

            render();
            updateBlackboardDisplay();
            updateTimeline();
        }

        function jumpToTimelinePosition(event) {
            if (event.target !== event.currentTarget) return; // Ignore handle clicks

            const track = document.getElementById('timelineTrack');
            const rect = track.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const percent = x / rect.width;
            const tickIndex = Math.floor(percent * simulationState.history.length);

            scrubToTick(Math.max(0, Math.min(tickIndex, simulationState.history.length - 1)));
        }

        function startTimelineDrag(event) {
            if (simulationState.history.length === 0) return;

            timelineState.isDragging = true;
            event.preventDefault();

            function onDrag(e) {
                if (!timelineState.isDragging) return;

                const track = document.getElementById('timelineTrack');
                const rect = track.getBoundingClientRect();
                const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                const percent = x / rect.width;
                const tickIndex = Math.floor(percent * simulationState.history.length);

                scrubToTick(Math.max(0, Math.min(tickIndex, simulationState.history.length - 1)));
            }

            function onDragEnd() {
                timelineState.isDragging = false;
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', onDragEnd);
            }

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', onDragEnd);
        }

        // Add keyboard controls for timeline
        document.addEventListener('keydown', (e) => {
            // Only handle timeline keys if timeline is visible and not typing in input
            if (document.getElementById('timelineScrubber').style.display === 'none') return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                prevTick();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                nextTick();
            } else if (e.key === 'Home') {
                e.preventDefault();
                scrubToTick(0);
            } else if (e.key === 'End') {
                e.preventDefault();
                returnToLive();
            }
        });

        // Show/hide timeline when simulation starts/stops
        const originalStartSimulation = startSimulation;
        startSimulation = function() {
            originalStartSimulation();
            showTimeline();
        };

        const originalResetSimulation = resetSimulation;
        resetSimulation = function() {
            originalResetSimulation();
            hideTimeline();
            simulationState.history = [];
            timelineState.playbackTick = -1;
        };

    </script>
</body>

</html>